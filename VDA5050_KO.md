![로고](./assets/logo.png)

# 자동화 된 가이드 차량 (AGV)과 마스터 컨트롤 간의 통신을위한 인터페이스

## VDA 5050

## 버전 2.1.0

![제어 시스템 및 자동화 된 가이드 차량](./assets/csagv.png)



### 간단한 정보

무인 운송 시스템 (DTS)을위한 통신 인터페이스의 정의.
이 권장 사항은 중앙 마스터 컨트롤과 자동화 된 가이드 차량 (AGV) 간의 순서 및 상태 데이터를 교환하기위한 통신 인터페이스를 설명합니다.



### 면책 조항

다음의 설명은 자동화 된 가이드 차량 (AGV)과 마스터 컨트롤 간의 통신을위한 인터페이스 실행 및 모든 사람에게 자유롭게 적용 할 수 있고 결합되지 않는 컨트롤을 실행하기위한 표시 역할을합니다.
신청하는 사람들은 특정 경우에 제대로 적용되도록해야합니다.

그들은 각 문제 당시 우세한 최첨단을 고려해야합니다.
제안서를 적용함으로써 아무도 자신의 행동에 대한 책임을지지 않습니다.
진술은 철저하거나 기존 법률의 정확한 해석에 대한 것이 아니라고 주장하지 않습니다.
관련 정책, 법률 및 규정에 대한 연구를 대체 할 수 없습니다.
또한, 각 제품의 특수 기능과 다른 가능한 응용 프로그램의 특수 기능을 고려해야합니다.
모든 사람은 이와 관련하여 자신의 위험에 따라 행동합니다.
VDA의 책임과 제안서의 개발 또는 적용에 관련된 책임은 제외됩니다.

제안서의 적용 또는 잘못된 해석 가능성에 부정확성을 만나면 VDA에 즉시 결함이 수정 될 수 있도록 즉시 알려주십시오.

**발행자**
Verband der Automobilindustie E.V. (VDA)
Behrenstraße 35, 10117 베를린,
독일
www.vda.de

**저작권**
자동차 산업 협회 (VDA)
재생산 및 기타 형태의 재생산은 소스의 사양으로 만 허용됩니다.

버전 2.1.0


## 목차

[1 미리 노드] (#1-foreword) <br>
[2 문서의 목표] (#2-Objective-of-Document) <br>
[3 스코프] (#3 스코프) <br>
[3.1 기타 적용 가능한 문서] (#31-기구 적용 문서) <br>
[4 가지 요구 사항 및 프로토콜 정의] (#4보고 및 프로토콜 정의) <br>
[5 커뮤니케이션 프로세스 및 내용] (#5 프로세스 및 콘텐츠 커뮤니케이션) <br>
[6 프로토콜 사양] (#6 ProTocol-Specification) <br>
[6.1 서식의 기호와 형식의 의미] (#61-symbols of-the-table and meaning of formatting) <br>
[6.1.1 선택 필드] (#611-optional fields) <br>
[6.1.2 허가 된 캐릭터 및 필드 길이] (#612-10-50-10-10-10-10 세) <br>
[6.1.3 열거의 표기법] (#613-unumerations-of-enumerations) <br>
[6.1.4 JSON 데이터 유형] (#614-JSON-DATA-TYPES) ​​<br>
[6.2 MQTT 연결 처리, 보안 및 QOS] (#62-MQTT-Connection Handling-Security and-QOS) <br>
[6.3 MQTT 주제 레벨] (#63-mqtt-topic 레벨) <br>
[6.4 프로토콜 헤더] (#64 Protocol-Header) <br>
[6.5 커뮤니케이션 주제] (#65-topics-for-communication) <br>
[6.6 주제 : "주문"(마스터 컨트롤에서 AGV로)] (#66 주제 마스터-마스터-조정-AGV) <br>
[6.6.1 개념 및 논리] (#661-concept and-logic) <br>
[6.6.2 주문 및 주문 업데이트] (#662-orders and-order-update) <br>
[6.6.3 주문 취소 (마스터 컨트롤에 의한)] (#663 주문-산맥별로 대조적으로 통제) <br>
[6.6.4 주문 거부] (#664-order-receject) <br>
[6.6.5 복도] (#665-Corridors) <br>
[6.6.6 주문 메시지의 구현] (#666- 중간 부작용) <br>
[6.7 맵] (#67 맵) <br>
[6.7.1지도 분포] (#671-MAP 분포) <br>
[6.7.2 차량 상태의지도] (#672 맵 차량-차량) <br>
[6.7.3지도 다운로드] (#673-Map-download) <br>
[6.7.4 다운로드 맵 활성화] (#674-enable downloaded-maps) <br>
[6.7.5 차량의지도 삭제] (#675-Delete-Maps-on-Vehicle) <br>
[6.8 조치] (#68- 액션) <br>
[6.8.1 사전 정의 된 동작의 정의, 매개 변수, 효과 및 범위] (#681 정의-파라미터-효과 및 예측 정의-행동) <br>
[6.8.2 사전 정의 된 조치의 상태] (#682-States of Predefined-Actions) <br>
[6.9 주제 : "Instantactions"(마스터 제어에서 AGV로)] (#69- 주제-내용-마스터-조정-AGV) <br>
[6.10 주제 : "State"(AGV에서 마스터 컨트롤까지)] (#610-topic-in-agv-master-control) <br>
[6.10.1 개념 및 논리] (#6101-concept and-logic) <br>
[6.10.2 노드의 횡단 및 가장자리에 입력/남기고, 행동의 트리거] (#6102-traversal-and-entering-edges-edges-of-accaction) <br>
[6.10.3 기본 요청] (#6103-base-request) <br>
[6.10.4 정보] (#6104 정보) <br>
[6.10.5 오류] (#6105- 오류) <br>
[6.10.6 상태 메시지의 구현] (#6106-reatse-message) <br>
[6.11 ActionStates] (#611-ActionStates) <br>
[6.12 액션 차단 유형 및 시퀀스] (#612- 액션 블로킹-타입 및 시퀀스) <br>
[6.13 주제 "시각화"] (#613 주제-방문) <br>
[6.14 주제 "연결"] (#614 주제 연결) <br>
[6.15 주제 "Factsheet"] (#615 주제 요소) <br>
[6.15.1 Factsheet JSON 구조] (#6151-FactSheet-JSON 구조) <br>
[7 모범 사례] (#7- 최고의 실습) <br>
[7.1 오류 참조] (#71- 오류 참조) <br>
[7.2 매개 변수 형식] (#72- 파라미터 형식) <br>
[8 용어집] (#8-Glossary) <br>
[8.1 정의] (#81 정의) <br>


# 1 머리말

인터페이스는 Verband der Automobilindustie E.V. 사이에 협력하여 확립되었습니다. (VDA) 및 VERBAND DEUTSCHER MASCHINEN- UND Anlagenbau e. V. (VDMA).
양 당사자의 목표는 보편적으로 적용 가능한 인터페이스를 만드는 것입니다.
인터페이스 변경에 대한 제안은 VDA에 제출되며 VDMA와 공동으로 평가되고 긍정적 인 결정의 경우 새 버전 상태로 채택됩니다.
GitHub를 통한이 문서에 대한 기여는 크게 감사합니다.
저장소는 다음 링크에서 찾을 수 있습니다 : https://github.com/vda5050/vda5050.


# 2 문서의 목표

권장 사항의 목적은 새로운 차량의 기존 마스터 제어 시스템에 대한 연결을 단순화하고 동일한 작업 환경에서 다른 제조업체 및 기존 시스템 (재고 시스템)의 AGV와의 병렬 작동을 가능하게하는 것입니다.

마스터 컨트롤과 AGV 사이의 균일 한 인터페이스가 정의되어야합니다.
이것은 다음과 같은 점에서 달성해야합니다.

- AGV와 마스터 컨트롤 간의 통신 표준에 대한 설명과 운송 시스템을 협동 전송 차량을 사용하여 연속 프로세스 자동화에 통합하기위한 기초.
- 무엇보다도 차량 자율성, 프로세스 모듈 및 인터페이스 증가, 바람직하게는 이벤트 제어 명령 체인의 단단한 시퀀스 분리를 ​​통해 유연성이 증가합니다.
- 필요한 정보 (예 : 주문 정보)가 중앙 서비스에서 제공되며 일반적으로 유효하기 때문에 "플러그 앤 플레이"기능이 높기 때문에 구현 시간이 줄어 듭니다. 차량은 산업 안전의 요구 사항을 고려하여 동일한 구현 노력으로 제조업체와 독립적으로 운영 할 수 있어야합니다.
- 모든 운송 차량, 차량 모델 및 제조업체에 대한 해당 논리와의 균일하고 중요한 조정을 통해 시스템의 "플러그 앤 플레이"기능의 복잡성 감소 및 증가.
- 차량 제어와 조정 수준 사이의 일반적인 인터페이스를 사용하여 제조업체의 독립성 증가.
- 독점 마스터 컨트롤과 초음파 마스터 컨트롤 사이의 수직 통신을 구현하여 독점 DTS 인벤토리 시스템의 통합 (그림 1).

![그림 1 DTS 인벤토리 시스템의 통합](./assets/concept_DTS.png)
> 그림 1 DTS 인벤토리 시스템의 통합

위에서 언급 한 목표를 구현하기 위해이 문서는 AGV와 마스터 제어 간의 주문 및 상태 정보 통신을위한 인터페이스를 설명합니다.

AGV와 마스터 컨트롤 사이의 작동에 필요한 다른 인터페이스 (예 : 경로 계획 등과 관련하여 특별한 기술을 자유롭게 고려 함) 또는 다른 시스템 구성 요소 (예 : 외부 주변 장치, 화재 보호 게이트 등)와 통신하는 데 필요한 다른 인터페이스는이 문서에 처음 포함되지 않습니다.


# 3 범위

이 권장 사항에는 자동화 된 가이드 차량 (AGV)과 마스터 제어 간의 커뮤니케이션에 관한 정의 및 모범 사례가 포함되어 있습니다.
목표는 다른 특성 (예 : 언더 런 트랙터 또는 포크 리프트 AGV)을 갖는 AGV가 균일 한 언어로 마스터 제어와 통신하도록하는 것입니다. 
이것은 마스터 컨트롤에서 AGV의 조합을 작동하기위한 기초를 만듭니다.
마스터 컨트롤은 주문을 제공하고 AGV 트래픽을 조정합니다.

인터페이스는 자동차 산업의 생산 및 플랜트 물류의 요구 사항을 기반으로합니다.
공식화 된 요구 사항에 따르면, 교합 내 요구 사항은 물류 부서의 요구 사항, 즉 자유롭게 탐색 차량 및 가이드 차량의 통제를 통해 물류 부서의 요구 사항, 즉 물품에서 생산 공급에 이르기까지 물류 프로세스를 포함합니다.

자동 차량과 달리 자율 주행 차량은 해당 센서 시스템 및 알고리즘을 기반으로 발생하는 문제를 독립적으로 해결하고 동적 환경의 변화에 ​​따라 반응하거나 그 후 곧 반응 할 수 있습니다.
독립적 인 우회 장애물과 같은 자율적 특성은 차량뿐만 아니라 차량을 자유롭게 탐색하여 충족 될 수 있습니다.
그러나 경로 계획이 차량 자체에서 수행 되 자마자이 문서는 차량을 자유롭게 탐색하는 것을 설명합니다 (용어집 참조).
자율 시스템은 완전히 분산되지 않았으며 (떼 지능) 사전 정의 된 규칙을 통해 동작을 정의했습니다.

지속 가능한 솔루션의 목적을 위해, 아래에 인터페이스가 그 구조에서 확장 될 수 있습니다.
이를 통해 안내 된 차량에 대한 마스터 컨트롤을 완전히 적용 할 수 있습니다.
자유롭게 탐색하는 차량은 구조물에 통합 될 수 있습니다. 이를 위해 필요한 세부 사양은이 권장 사항의 일부가 아닙니다.

독점 재고 시스템의 통합을 위해서는 인터페이스의 개별 정의가 필요할 수 있으며,이 권장 사항의 일부로 간주되지 않습니다.


## 3.1 기타 해당 문서

문서 | 버전 | 설명
--- | --- | ---
VDI 지침 2510 | 2005 년 10 월 | 무인 운송 시스템 (DTS)
VDI 가이드 라인 4451 시트 7 | 2005 년 10 월 | 무인 운송 시스템 (DTS)의 호환성 -DTS 마스터 컨트롤
DIN EN ISO 3691-4 | 2023 년 12 월 | 산업용 트럭 안전 요구 사항 및 검증 파트 4 : 무인 트럭 및 시스템
LIF - 레이아웃 인터체인지 형식 | 2024 년 3 월 | 무인 운송 차량의 통합 자와 (타사) 마스터 제어 시스템 간의 교환을위한 트랙 레이아웃 형식의 정의.

# 4 요구 사항 및 프로토콜 정의

통신 인터페이스는 다음 요구 사항을 지원하도록 설계되었습니다.

- 최소 제어. 1000 대의 차량
- 차량의 자율 정도가 다른 차량의 통합 가능
- 경로 선택 또는 교차로에서의 동작과 관련하여 결정을 활성화합니다.

차량은 정기적으로 또는 상태가 변경 될 때 상태를 양도해야합니다.

통신은 연결 고장 및 메시지 손실의 영향을 고려하여 무선 네트워크를 통해 수행됩니다.

메시지 프로토콜은 MQTT (Message Ceareing Telemetry Transport)이며 JSON 구조와 함께 사용됩니다.
MQTT 3.1.1 은이 프로토콜을 개발하는 동안 테스트되었으며 호환성에 필요한 최소 버전입니다.
MQTT는 메시지를 "주제"라고하는 서브 채널로 배포 할 수 있습니다.
MQTT 네트워크의 참가자는 이러한 주제를 구독하고 관심사 또는 관심있는 정보를받습니다.

JSON 구조는 추가 매개 변수로 프로토콜의 향후 확장을 허용합니다.
매개 변수는 영어로 설명되어 프로토콜을 읽을 수 있고 이해할 수 있으며 독일어를 사용하는 지역 밖에서 적용 할 수 있도록합니다.


# 5 커뮤니케이션 프로세스 및 내용

AGV 운영에 대한 다음과 같은 참가자가 있습니다.

- AGV 시스템의 운영자는 기본 정보를 제공합니다.
- 마스터 컨트롤은 작업을 구성하고 관리합니다
- AGV는 명령을 내립니다

그림 2는 작동 단계에서의 통신 내용을 설명합니다.
구현 또는 수정 중에 AGV 및 마스터 컨트롤이 수동으로 구성됩니다.

![그림 2 정보 흐름의 구조](./assets/information_flow_VDA5050.png)
> 그림 2 정보 흐름의 구조

구현 단계에서 마스터 제어 및 AGV로 구성된 무인 운송 시스템 (DTS)이 설정됩니다.
필요한 프레임 워크 조건은 운영자에 의해 정의되며 필요한 정보는 수동으로 입력하거나 다른 시스템에서 가져 와서 마스터 컨트롤에 저장됩니다.
본질적으로 이것은 다음 내용과 관련이 있습니다.

- 경로 정의 : CAD를 이용하여 경로를 마스터 컨트롤로 가져오거나 수동으로 설정 가능.
일방통행, 특정 차량 그룹 제한 등의 조건 지정 가능
경로는 단방향 거리 일 수 있으며 특정 차량 그룹 (크기 비율 기준) 등의 경우 제한 될 수 있습니다.
- 루트 네트워크 구성 :
경로 내에서 로딩 및 하역 스테이션, 배터리 충전소, 주변 환경 (게이트, 엘리베이터, 장벽), 대기 위치, 버퍼 스테이션 등이 정의됩니다.
- 차량 구성 : AGV (크기, 사용 가능한 부하 캐리어 마운트 등)의 물리적 특성은 연산자가 저장합니다.
AGV는이 문서의``Factsheet']주제를 통해이 정보를 특정 방식으로 [6.15 주제 "Factsheet"] (#615 주제 요소 시트)에 정의 된 특정 방식으로 통신해야합니다.

위에서 설명한 경로 구성 및 경로 네트워크는이 문서의 일부가 아닙니다.
이 정보를 기반으로 마스터 컨트롤에 의한 주문 제어 및 운전 코스 할당을 가능하게하는 기준을 형성하고 전송 요구 사항을 완료 할 수 있습니다.
그런 다음 AGV에 대한 결과 주문은 MQTT 메시지 브로커를 통해 차량으로 전송됩니다.
그런 다음 직무 실행과 병렬로 마스터 컨트롤에 대한 상태를 지속적으로보고합니다.
이것은 MQTT 메시지 브로커를 사용하여 수행됩니다.

마스터 컨트롤의 기능은 다음과 같습니다.

- AGV에 주문 할당
- 경로 계산 및 AGV 이동 경로 안내 (AGV의 크기, 기동성 등 물리적 한계 고려)
- 장애물 감지 및 교착 상태(Deadlock) 해결
- 에너지 관리: 충전 작업이 운송 작업보다 우선될 수 있음
- 교통 관리: 버퍼 경로 및 대기 위치 관리
- 환경 변화 대응 (일부 영역 개방, 속도 제한 변경 등)
- 주변 시스템(문, 게이트, 엘리베이터 등)과의 통신
- 통신 오류 감지 및 해결

AGV의 기능은 다음과 같습니다.

- 위치 파악(Localization)
- 경로 내비게이션 (가이드 경로 또는 자율 경로)
- 행동(Action) 실행
- 차량 상태 지속 전송

시스템 통합 시 고려 사항 (일부 목록)

- 지도 구성: 마스터 컨트롤과 AGV 간 좌표계를 일치시켜야 함
- 기준점(Pivot Point) 설정: AGV의 회전 중심점이 다를 수 있음 (적재 여부에 따라 변동 가능)


# 6 프로토콜 사양

다음 섹션에서는 통신 프로토콜의 세부 사항을 설명합니다.
이 프로토콜은 마스터 컨트롤과 AGV 간의 통신을 지정합니다.
AGV와 주변 장치 사이의 통신, 예를 들어 AGV와 게이트 사이의 통신은 제외됩니다.

다른 메시지는 순서, 상태 등으로 전송되는 JSON 필드의 내용을 설명하는 테이블에 표시됩니다.

또한 JSON Schemas는 공개 git 저장소 (https://github.com/vda5050/vda5050)에서 검증 할 수 있습니다.
JSON 스키마는 VDA5050의 모든 릴리스마다 업데이트됩니다. JSON 스키마 와이 문서간에 차이가있는 경우이 문서의 변형이 적용됩니다.


## 6.1 서식의 기호 및 형식의 의미

테이블에는 식별자 이름, 장치, 데이터 유형 및 설명이 포함되어 있습니다.

식별 | 설명
--- | ---
standard | 변수는 기본 데이터 유형입니다
bold (굵게) | 변수는 비기본 데이터 유형(JSON 객체 또는 배열 등)이며, 별도로 정의됩니다.
italic (이탤릭) | 변수는 선택 사항입니다
italic and bold (이탤릭 + 굵게) | 변수는 선택 사항이며 비기본 데이터 유형입니다.
arrayName[arrayDataType] | 변수(arrayName)는 배열이며, 대괄호 안의 데이터 유형(arrayDataType)으로 구성됩니다.

모든 키워드는 대소문자를 구분합니다.모든 필드 이름은 camelCase를 사용하며, 열거형(enumeration)은 대문자(UPPERCASE)로 작성되며 밑줄(_)을 사용하지 않습니다.


### 6.1.1 선택 필드

변수가 선택 사항으로 표시되는 경우, 특정 경우에 변수가 적용되지 않을 수 있으므로 (예 : 마스터 컨트롤이 AGV에 주문을 보낼 때, 일부 AGV는 궤적 자체와 필드의 'Edge'객체 내에서 궤적을 계획 할 수 있기 때문에 변수가 선택 사항임을 의미합니다).

AGV 가이 프로토콜에서 옵션으로 표시된 필드를 포함하는 메시지를 수신하는 경우 AGV는 그에 따라 행동 할 것으로 예상되며 필드를 무시할 수 없습니다.
AGV가 그에 따라 메시지를 처리 ​​할 수없는 경우, 예상되는 동작은 오류 메시지 내에서 이것을 전달하고 순서를 거부하는 것입니다.

마스터 제어는 AGV가 지원하는 선택적 정보 만 보내야합니다.

예 : 궤적은 선택 사항입니다.
AGV가 궤적을 처리 할 수없는 경우 마스터 제어는 차량에 궤적을 보내지 않아야합니다.

AGV는 AGV` Factsheet '메시지를 통해 필요한 선택적 매개 변수를 전달해야합니다.


### 6.1.2 허가 된 문자 및 필드 길이

모든 커뮤니케이션은 UTF-8로 인코딩되어 국제적 설명의 적응을 가능하게합니다.
권장 사항은 IDS가 다음 문자 만 사용해야한다는 것입니다.

A-Z A-Z 0-9 _-. :

최대 메시지 길이는 정의되지 않지만 MQTT 프로토콜 사양과 팩트 시트 내부에서 정의 된 기술적 제약 조건에 의해 제한됩니다.
AGVS 메모리가 들어오는 순서를 처리하기에 충분하지 않은 경우 주문을 거부해야합니다.
최대 필드 길이, 문자열 길이 또는 값 범위의 일치는 적분기에 달려 있습니다.
통합의 용이성을 위해 AGV 공급 업체는 [팩트 시트 섹션] (#616 주제 요소 시트)에 자세히 설명 된 AGV 사실 시트를 제공해야합니다.


### 6.1.3 필드, 주제 및 열거의 표기법

이 문서의 주제와 필드는 다음 스타일로 강조 표시됩니다.
열거는 대문자로 작성되어야한다. 이 값은 문서의 단일 따옴표로 둘러싸여 있습니다.
여기에는 'ActionStatus'필드 ( '대기', '완성'등과 같은 키워드가 포함됩니다.


### 6.1.4 JSON 데이터 유형

가능한 경우 JSON 데이터 유형을 사용해야합니다.
따라서 부울 값은 열거 ( 'true', 'false') 또는 마법 숫자가 아닌 "true"또는 "false"로 인코딩됩니다.
수치 데이터 유형은 유형 및 정밀도, 예를 들어 Float64 또는 UINT32로 지정됩니다. NAN 및 Infinity와 같은 IEEE 754의 특수 숫자 값은 지원되지 않습니다.


## 6.2 MQTT 연결 처리, 보안 및 QOS

MQTT 프로토콜은 클라이언트를위한 마지막 Will 메시지를 설정하는 옵션을 제공합니다.
어떤 이유로 든 클라이언트가 예기치 않게 단절되면 마지막 유언장은 브로커가 다른 구독 클라이언트에 배포합니다.
이 기능의 사용은 섹션 [6.14 주제 "Connection"] (#614 주제 연결)에 설명되어 있습니다.

AGV가 브로커와의 연결을 끊는 경우 모든 주문 정보를 유지하고 마지막 릴리스 노드까지 순서를 충족시킵니다.

브로커 구성에 의해 프로토콜 보안을 고려해야합니다.

통신 오버 헤드를 줄이기 위해 MQTT QOS 레벨 0 (최선의 노력)은`order ','instantAction ',`state`,'팩트 시트 '및'시각화 '주제에 사용됩니다.
'Connection'주제는 QOS 레벨 1 (적어도 한 번)을 사용해야합니다.


## 6.3 MQTT 주제 레벨

MQTT 주제 구조는 클라우드 제공 업체의 필수 주제 구조로 인해 엄격하게 정의되지 않습니다.
클라우드 기반 MQTT 브로커의 경우이 프로토콜에 정의 된 주제와 일치하도록 주제 구조를 개별적으로 조정해야합니다.
이것은 다음 섹션에 정의 된 주제 이름이 필수임을 의미합니다.

로컬 브로커의 경우 MQTT 주제 레벨이 다음과 같이 제안됩니다.

** 인터페드 인 인터페이스/메이저 버전/제조업체/SerialNumber/Topic **

예:
```
UAGV/V2/KIT/0001/ORDER
```

MQTT 주제 수준 | 데이터 유형 | 설명
--- | --- | ---
인터페드 이름 | 문자열 | 중고 인터페이스의 이름
전환 | 문자열 | VDA 5050 권장 사항의 주요 버전 번호 "V"
제조업체 | 문자열 | AGV의 제조업체.
SerialNumber | 문자열 | 다음 문자로 구성된 고유 한 AGV 일련 번호 : <br> a-z <br> a-z <br> 0-9 <br> _ <br>. <br> : <br>-
주제 | 문자열 | 주제 (예 : 순서 또는 상태) 섹션 [6.5 커뮤니케이션 주제] 참조 (#65-topics-for-communication)

참고 :`/`문자는 주제 계층을 정의하는 데 사용되므로, 위에서 언급 한 필드에서는 사용되지 않아야합니다.
`$`캐릭터는 일부 MQTT 브로커에서 특별한 내부 주제를 위해 사용되므로 사용해서는 안됩니다.


## 6.4 프로토콜 헤더

각 JSON 메시지는 헤더로 시작합니다.
다음 섹션에서는 다음 필드가 가독성을위한 헤더로 참조됩니다.
헤더는 다음 개별 요소로 구성됩니다.
헤더는 JSON 객체가 아닙니다.

객체 구조/식별자 | 데이터 유형 | 설명
--- | --- | ---
Headerid | UINT32 | 메시지의 헤더 ID. <br> Headerid는 주제별로 정의되며 각각의 전송 된 (그러나 반드시 수신 할 필요는 없지만) 1으로 증가합니다.
타임 스탬프 | 문자열 | 타임 스탬프 (ISO 8601, UTC); yyyy-mm-ddthh : mm : ss.ffz (예 : "2017-04-15t11 : 40 : 03.12z").
버전 | 문자열 | 프로토콜의 버전 [major]. [minor]. [patch] (예 : 1.3.2).
제조업체 | 문자열 | AGV의 제조업체.
SerialNumber | 문자열 | AGV의 일련 번호.


### 프로토콜 버전

프로토콜 버전은 시맨틱 버전을 버전 관리 스키마로 사용합니다.

주요 버전 변경에 대한 예 :

- 새로운 비 옵션 필드와 같은 변화를 깨뜨립니다

사소한 버전 변경에 대한 예 :

- 시각화를위한 추가 주제와 같은 새로운 기능

패치 버전의 예 :

- 배터리 충전의 경우 가용 정밀도가 높습니다


## 6.5 커뮤니케이션 주제

AGV 프로토콜은 마스터 컨트롤과 AGV 간의 정보 교환을 위해 다음 주제를 사용합니다.

Topic name | Published by | Subscribed by | Used for | Implementation | Schema
---|---|---|---|---|---
order | master control | AGV | Communication of driving orders from master control to the AGV | mandatory | order.schema
instantActions | master control | AGV | Communication of the actions that are to be executed immediately | mandatory | instantActions.schema
state | AGV | master control | Communication of the AGV state | mandatory | state.schema
visualization | AGV | Visualization systems | Higher frequency of position topic for visualization purposes only | optional | visualization.schema
connection | Broker/AGV | master control | Indicates when AGV connection is lost, not to be used by master control for checking the vehicle health, added for an MQTT protocol level check of connection | mandatory | connection.schema 
factsheet | AGV | master control | Parameters or vendor-specific information to assist set-up of the AGV in master control | mandatory | factsheet.schema



## 6.6 "order" (from master control to AGV)

"Order"주제는 AGV가 JSON 캡슐화 된 순서를받는 MQTT 주제입니다.


### 6.6.1 개념 및 논리

주문의 기본 구조는 **노드와 엣지로 이루어진 그래프**입니다. AGV는 노드와 엣지를 따라 이동하여 주문을 수행해야 합니다.모든 노드와 엣지가 연결된 전체 그래프는 마스터 컨트롤이 관리합니다.

마스터 컨트롤 내 그래프 표현에는 **제한 사항**이 포함될 수 있습니다. 예를 들어, 특정 AGV만 특정 엣지를 이동할 수 있도록 설정될 수 있습니다.그러나 **이러한 제한 사항은 AGV로 전달되지 않으며**, 마스터 컨트롤은 AGV가 이동할 수 있는 엣지만을 주문에 포함시킵니다.

![Figure 3 Graph representation in master control and graph transmitted in orders](./assets/graph_representation_transmission.png)
> 그림 3 주문으로 전송 된 마스터 제어 및 그래프의 그래프 표현

AGV에 전달되는 주문 메시지(order message) 내에서, 노드와 엣지는 각각 두 개의 리스트로 전달됩니다.이 리스트 내의 노드 및 엣지 순서는 AGV가 이동해야 하는 순서를 결정합니다.

**유효한 주문 조건**
- 최소한 하나 이상의 노드가 포함되어야 합니다.
- 엣지 수는 노드 수보다 하나 적어야 합니다 (즉, N개의 노드 → N-1개의 엣지).
- 첫 번째 노드는 AGV가 즉시 도달할 수 있어야 합니다.
- AGV가 이미 해당 노드에 위치해 있거나, 노드의 허용 오차 범위(deviation range) 내에 있어야 합니다.

노드와 엣지에는 각각 `released` **(해제됨) 속성**이 존재합니다.
- `released = true` → AGV는 해당 노드/엣지를 이동해야 합니다.
- `released = false` → AGV는 해당 노드/엣지를 이동할 수 없습니다.
엣지가 released 상태가 되려면, 해당 엣지의 시작 노드와 끝 노드 모두 released 상태여야 합니다.

**기본 집합(Base)과 지평선(Horizon)**
- 기본 집합(Base): `released` 상태의 노드 및 엣지 집합
- 지평선(Horizon): `released = false` 상태의 노드 및 엣지 집합

주문 메시지는 반드시 지평선을 포함할 필요는 없습니다.

**부분 주문 (Sub-Orders)**
주문 메시지는 반드시 전체 운송 경로를 포함할 필요가 없습니다.
- 교통 제어(Traffic Control) 및 자원이 제한된 AGV를 고려하여, 전체 운송 경로(여러 노드 및 엣지로 구성됨)를 여러 개의 부분 주문(sub-orders)으로 나눌 수 있습니다.
- 이러한 부분 주문은 **orderId 및 orderUpdateId**를 통해 서로 연결됩니다.
- 주문의 업데이트 방식은 다음 섹션에서 설명됩니다.


### 6.6.2 주문 및 주문 업데이트

트래픽 관리를 지원하기 위해 마스터 제어는 순서를 통해 통신 된 경로를 두 부분으로 나눌 수 있습니다.

- **Base**: AGV가 이동할 수 있도록 허가된 경로입니다. 기본 경로의 모든 노드와 엣지는 마스터 컨트롤에 의해 이미 `released` 상태입니다. 기본 경로의 마지막 노드를 **결정 지점(Decision Point)**이라고 합니다.
- **Horizon**: 마스터 컨트롤이 결정 지점 이후에 AGV가 이동하도록 계획한 경로입니다. 이 경로는 아직 `released` 상태가 아닙니다.

AGV는 만약 새로운 노드와 엣지가 Base에 추가되지 않으면 **결정 지점에서 정지**해야 합니다.마스터 컨트롤은 교통 상황이 허용하는 경우, AGV가 결정 지점에 도달하기 전에 Base를 확장하여 AGV가 원활하게 이동할 수 있도록 해야 합니다.

MQTT는 비동기식 프로토콜이며, 무선 네트워크를 통한 전송이 항상 신뢰할 수 있는 것은 아니므로 **Base를 변경할 수 없습니다**.마스터 컨트롤은 **AGV가 이미 Base를 실행했다고 가정**해야 합니다.주문 취소 절차는 다음 섹션에서 설명되지만, 앞서 언급한 통신 제한으로 인해 신뢰할 수 없는 방식으로 처리될 수 있습니다.

![그림 4 구동 경로 변경 "Horizon"](./assets/driving_route_horizon.png)
> 그림 4 구동 경로 변경 "지평선"절차

그림 4에서, 초기 작업은 시간 t = 1에 제어판에 의해 먼저 전송됩니다.
그림 5는 가능한 작업의 의사 코드를 보여줍니다.
가독성을 위해, 완전한 JSON 예제는 여기에서 생략되었습니다.

```
{
	orderId: "1234"
	orderUpdateId:0,
	nodes: [
		 f {released: True},
		 d {released: True},
		 g {released: True},
		 b {released: False},
		 h {released: False}
	],
	edges: [
		e1 {released: True},
		e3 {released: True},
		e8 {released: False},
		e9 {released: False}
	]
}
```
> 그림 5 순서의 의사 코드.

주문 확장 예제 (t=3, 그림 6 참조)

- `orderUpdateId`가 증가되며, 새 `Base`의 첫 번째 노드는 이전 주문에서 공유된 마지막 `Base` 노드와 동일해야 합니다.
- AGV가 업데이트를 수행할 수 있도록, 기존에 알고 있는 엣지를 따라 이동하여 새 노드에 도달할 수 있어야 합니다.

```
{
	orderId: 1234,
	orderUpdateId: 1,
	nodes: [
		 g {released: True},
		 b {released: True},
		 h {released: True},
		 i {released: False}
	],
	edges: [
		e8 {released: True},
		e9 {released: True},
		e10 {released: False}
	]
}
```
> 그림 6 주문 업데이트의 의사 코드. `orderupdateId`의 변경 사항에 유의하십시오.

만약 AGV가 주문 업데이트를 수신하지 못하면(`orderUpdateId`가 누락됨), AGV는 마지막으로 받은 `Base` 노드가 새로운 `Base`의 첫 번째 노드와 일치하는지 확인할 수 있습니다.

마스터 컨트롤은 **Horizon을 완전히 새로운 `Base`로 변경할 수 있으며, 필요하면 Horizon을 삭제할 수도 있습니다**.

![그림 7 정규 업데이트 프로세스 - 주문 확장](./assets/update_order_extension.png)
> 그림 7 정기 업데이트 프로세스 - 주문 확장.

그림 7은 순서를 어떻게 확장 해야하는지 설명합니다.
현재 AGV에서 사용할 수있는 정보가 표시됩니다.
`orderid`는 동일하게 유지되고 `orderupdateid`는 증가합니다.

이전베이스의 마지막 노드는 업데이트 된 순서의 첫 번째 기본 노드입니다.
이 노드를 사용하면 AGV는 업데이트 된 순서를 현재 순서 (스티칭)에 추가 할 수 있습니다.
이전베이스의 다른 노드와 가장자리는 분개되지 않습니다.

마스터 컨트롤은 완전히 다른 노드를 새 기지로 보내서 수평선을 변경할 수있는 옵션이 있습니다.
수평선도 삭제할 수도 있습니다.

순서에서 루프를 허용하려면 (노드 A에서 B로 이동 한 다음 A로 돌아 가면) a `sequenceId`가 노드 및 에지 개체에 할당됩니다.
이`sequenceId`는 노드와 가장자리를 통해 실행됩니다 (순서의 첫 번째 노드는 0을, 첫 번째 모서리는 1을 가져오고 1을 가져오고, 두 번째 노드는 2 등을 가져옵니다).
이를 통해 주문 진행 상황을보다 쉽게 ​​추적 할 수 있습니다.

A `sequenceId`가 할당되면, 주문 업데이트에 따라 변경되지 않습니다 (그림 7 참조).
이것은 마스터 컨트롤이 언급하는 AGV 측에서 결정하는 데 필요합니다.

그림 8은 주문 또는 주문 업데이트를 수락하는 프로세스를 설명합니다.

![Figure 8 The process of accepting an order or orderUpdate](./assets/process_order_update.png)
> 그림 8 주문 또는 주문 업데이트 수락 프로세스.

1) **는 주문 유효합니까? ** :
모든 서식 및 JSON 데이터 유형이 맞습니까?

2) ** 주문 신규 또는 현재 주문의 업데이트? ** :
수신 된 명령의 'OrderId'는 차량이 현재 보유하고있는 주문의`orderd '와 다릅니 까?

3) ** 차량은 여전히 ​​주문을 실행하거나 업데이트를 기다리고 있습니까? ** :
`Nodestates '가 비어 있지 않거나'ActionStates '가'실패하지도 않았거나 '완료'가 아닌 상태가 포함되어 있습니까? 노드와 가장자리와 주문 수평선의 해당 조치 상태도 상태 내부에 포함됩니다. 차량에는 여전히 수평선이 있으므로 업데이트를 기다리고 주문을 실행할 수 있습니다.

4) **는 현재 위치에 충분히 가까운 새 순서가 시작됩니까? ** : 차량이 이미 노드에 서 있거나 노드의 편차 범위에 있습니까 (섹션 [6.6.1 개념 및 논리] (#661 개념 및 로그)?

5) ** 주문 업데이트가 더 이상 사용되지 않습니까? ** :`orderupDateId '는 현재 차량에있는 것보다 작습니까?

6) ** 현재 차량에서 주문 업데이트가 수신 되었습니까? ** :`OrderUpDateId '는 현재 차량에있는 것과 동일합니까?

7) ** 수신 업데이트는 현재 여전히 실행중인 순서의 유효한 연속입니까? ** : 수신 된 순서의 첫 번째 노드는 현재 결정 지점 (현재 기반의 마지막 노드)과 동일합니까? 차량은 여전히 ​​이전 주문 업데이트로 출시 된 기지와 관련된 조치를 계속 움직이거나 실행 중이거나 여전히 지평선이 있으므로 주문의 연속을 기다리고 있습니다. 이 경우 새베이스의 첫 번째 노드가 이전베이스의 마지막 노드와 같으면 주문 업데이트가 허용됩니다.

8) ** 수신 된 업데이트는 이전에 완료된 순서의 유효한 연속입니까? ** : 수신 된 주문 업데이트의 첫 번째 노드의`nodeid` 및`equenceId '는`lastnodeid` 및`lastNodeDequenceId`와 같습니까? 차량은 더 이상 어떤 행동도 실행하지 않습니다. 주문의 연속을 기다리고 있지는 않습니다 (즉, 모든 관련 조치로 기본을 완료했으며 수평선이 없습니다). 주문 업데이트는 이제 마지막 트래버스 노드에서 계속되면 허용되므로 새베이스의 첫 번째 노드는`lastNodeDequenceID '뿐만 아니라 차량의'lastNodeId '와 일치해야합니다.

9)주기/부속 상태는 'ActionStates`/`Nodestates`/`edgestates'를 말합니다.


### 6.6.3 주문 취소 (마스터 제어에 의해)

기본 노드에서 계획되지 않은 변경이있는 경우, 인스턴트 actormation`canceorder '를 사용하여 주문을 취소해야합니다.

인스턴트 actact`cancelorder '를 수신 한 후 차량은 (예를 들어, 오른쪽 또는 다음 노드의 기능을 기준으로) 중지됩니다.

예정된 조치가있는 경우, 이러한 조치는 'ActionState'에서 '실패'를 취소하고보고해야합니다.
실행되는 조치가있는 경우 해당 조치를 취소하고 '실패'로보고해야합니다.
조치를 중단 할 수없는 경우, 해당 조치의 'ActionState'는 실행중인 '실행'을보고하고 각 상태 ( '완료', 성공하고 '실패한 경우')를보고함으로써이를 반영해야합니다.
작업이 실행되는 동안 ConcelOrder 조치는 모든 작업이 취소/완료 될 때까지 '실행'을보고해야합니다.
차량의 모든 움직임과 모든 행동이 중단 된 후에 'CancelOrder'행동 상태는 '완료'라고보고해야합니다.

`orderid`와`orderupdateid '는 보관됩니다.

그림 9는 다른 AGV 기능에 대한 예상 동작을 보여줍니다.

!
> 그림 9`cancelorder '후에 예상되는 동작.
#### 6.6.3.1 취소 후 새 주문을받습니다

주문 취소 후, 차량은 새로운 명령을 받기 위해 상태에 있어야합니다.

태그를 통해 노드에 위치하는 AGV의 경우, 새로운 순서는 이제 AGV가 서있는 노드에서 시작해야합니다 (그림 5 참조).

노드 사이에서 멈출 수있는 AGV의 경우 다음 순서를 시작 해야하는 방법을 통제 할 수 있습니다.
AGV는 두 가지 방법을 모두 수락해야합니다.

두 가지 옵션이 있습니다.

- 첫 번째 노드가 AGV가 현재 서있는 위치에 위치한 임시 노드 인 순서를 보내십시오. AGV는이 노드가 사소하게 도달 할 수 있고 순서를 수락한다는 것을 인식해야합니다.
- 첫 번째 노드가 이전 순서의 마지막 통과 노드 인 순서를 보내지 만 편차 범위를 AGV 가이 범위 내에있을 정도로 크게 설정하십시오. 따라서 AGV는이 노드가 순서대로 계산되고 순서를 수락해야한다는 것을 인식해야한다.


#### 6.6.3.2 AGV가 주문할 때 취약점 조치를 받음

AGV가 'CancelOrder'조치를받지 만 AGV에 현재 주문이 없거나 이전 주문이 취소 된 경우 'CancelOrder'조치는 '실패'로보고됩니다.

AGV는 'errorlevel'이 '경고'로 설정된 "NoorderTocancel"오류를보고해야합니다.
'인스턴트 션'의`actionId '는'오류 회의 '로 전달됩니다.


### 6.6.4 주문 거부

주문이 거부 될 때 몇 가지 시나리오가 있습니다.
이 시나리오는 그림 8에 나와 있으며 아래에 설명되어 있습니다.


#### 6.6.4.1 차량은 새로운 주문을받습니다

해결:

1. 차량은 내부 버퍼에서 새 순서를 인수하지 않습니다.
2. 차량은 경고 "ValidationError"를보고합니다.
3. 차량이 새로운 명령을 수락 할 때까지 경고는보고되어야한다.


#### 6.6.4.2 차량은 수행 할 수없는 작업이나 사용할 수없는 필드와의 명령을받습니다.

예 :

- 실행 불가능한 동작 : 최대 리프팅 높이보다 높이 올리거나 뇌졸중이 설치되지 않더라도 리프팅 동작 등
- 사용 불가능한 필드 : 궤적 등

해결:

1. 차량은 내부 버퍼에서 새 순서를 인수하지 않습니다.
2. 차량은 잘못된 필드가있는 "OrderError"를 오류 참조로보고합니다.
3. 차량이 새로운 명령을 수락 할 때까지 경고는보고되어야한다.


#### 6.6.4.3 차량은 동일한 OrderID를 가진 새 주문을 받지만 현재 OrderUpDateId보다 더 낮은 OrderUpDateId

해결:

1. 차량은 내부 버퍼에서 새 순서를 인수하지 않습니다.
2. 차량은 이전 주문을 버퍼로 유지합니다.
3. 차량은 "OrderUpDateError"경고를보고합니다.
4. 차량은 이전 주문을 계속 수행합니다.

AGV가 동일한`orderid` 및`orderupdateId`의 순서를 두 번 받으면, 두 번째 주문은 무시됩니다. 
마스터 컨트롤이 마스터 제어에 의해 너무 늦게 수신되어 첫 번째 주문이 접수되었는지 확인할 수 없기 때문에 마스터 컨트롤이 주문을 재개하면 발생할 수 있습니다.

### 6.6.5 복도

옵션 '복도'가장자리 속성을 사용하면 차량이 장애물 회피를 위해 에지 궤적에서 벗어날 수 있으며 차량이 작동 할 수있는 경계를 정의합니다.
'복도'속성을 사용하려면 '복도'속성이 정의되지 않은 경우 차량이 따라야하는 사전 정의 된 궤적이 필요합니다. 이것은 마스터 컨트롤에 알려진 차량에 정의 된 궤적이거나 순서대로 전송 된 궤적 일 수 있습니다. '복도'속성을 사용하는 차량의 동작은 여전히 ​​선과 차량의 동작입니다.

*주목:
주문 내부의 가장자리는 두 노드 사이의 논리적 연결을 정의하고 반드시 시작 노드에서 끝 노드로 운전할 때 차량이 따르는 (실제) 궤적은 아닙니다.
차량 유형에 따라 차량이 시작 및 끝 노드 사이를 취하는 궤적은 궤적 가장자리 속성을 통해 마스터 제어로 정의되거나 차량에 사전 정의 된 궤적으로 할당됩니다.
차량의 내부 상태에 따라 선택된 궤적은 다를 수 있습니다.*

![그림 10 복도 속성이있는 가장자리.](./assets/edges_with_corridors.png)
> 그림 10 차량이 미리 정의 된 궤적에서 벗어나 장애물을 피하기 위해 왼쪽 및 오른쪽 경계를 정의하는 '복도'속성이있는 가장자리. 왼쪽에서 운동 학적 중심은 허용 편차를 정의하고 오른쪽에는 하중에 의해 확장 될 수있는 차량의 윤곽은 허용 편차를 정의합니다. 이것은`corridorrefpoint` 매개 변수로 정의됩니다.

차량이 독립적으로 탐색 할 수있는 영역 (원래 가장자리 궤적에서 벗어나)은 왼쪽과 오른쪽 경계로 정의됩니다.
옵션 'CorridorRefpoint'필드는 차량 제어 지점 또는 차량 윤곽이 정의 된 경계 내부에 있어야하는지 여부를 지정합니다.
가장자리의 경계는 차량이 노드를 통과하자마자 새로운 및 현재 모서리의 경계 안에있는 방식으로 정의되어야합니다.
복도 경계를 0으로 설정하는 대신, 마스터 컨트롤은 차량이 궤적에서 벗어나지 않는 경우 '복도'속성을 사용해서는 안됩니다.

차량의 모션 제어 소프트웨어는 차량이 정의 된 경계 내에 있는지 지속적으로 확인해야합니다.
그렇지 않은 경우, 차량은 허용 된 탐색 공간을 벗어나서 오류를보고하기 때문에 정지해야합니다.
마스터 컨트롤은 사용자 상호 작용이 필요한지 또는 현재 주문을 취소하고 차량이 다시 이동할 수있는 복도 정보를 사용하여 차량에 새 주문을 보낼 수 있는지 결정할 수 있습니다.

*비고 : 차량이 궤적에서 벗어나도록 허용하면 운전 중에 차량의 발자국이 증가합니다. 이 상황은 초기 운영 중에 고려되어야하며 마스터 제어가 차량의 발자국을 기반으로 교통 통제 결정을 내린 경우.*

자세한 내용은 섹션 [6.10.2 노드의 순회 및 입력/떠나기/퇴치] (#6102-traversal-and-enterering-edges-trigger-of-action-of-actions)을 참조하십시오.


## 6.6.6 주문 메시지 구현

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
Headerid | | UINT32 | 메시지의 헤더 ID. <br> 헤더 ID는 주제별로 정의되며 전송 된 각각 (반드시 수신 할 필요는 없지만)마다 1으로 증가합니다.
타임 스탬프 | | 문자열 | 타임 스탬프 (ISO 8601, UTC); yyyy-mm-ddthh : mm : ss.ffz (예 : "2017-04-15t11 : 40 : 03.12z")
버전 | | 문자열 | 프로토콜의 버전 [major]. [minor]. [patch] (예 : 1.3.2)
제조업체 | | 문자열 | AGV의 제조업체
SerialNumber | | 문자열 | AGV의 일련 번호
ORDERID | | 문자열 | 주문 식별. <br> 이것은 동일한 순서에 속하는 여러 주문 메시지를 식별하는 데 사용됩니다.
OrderupDateId | | UINT32 | 주문 업데이트 식별. <br> orderid 당 고유합니다. <br> 주문 업데이트가 거부되면이 필드는 거부 메시지에 전달됩니다.
* ZonesetId* | | 문자열 | AGV가 내비게이션에 사용해야하거나 계획을 위해 마스터 컨트롤에서 사용한 영역 세트의 고유 식별자. <br> <br> 선택 사항 : 일부 마스터 제어 시스템은 영역을 사용하지 않습니다. <br> 일부 AGV는 영역을 이해하지 못합니다. <br> 구역이 사용되지 않으면 메시지에 추가하지 마십시오.
** 노드 [노드] ** | | 배열 | 순서를 이행하기 위해 트래버링 할 노드 객체의 배열. <br> 하나의 노드는 유효한 순서로 충분합니다. <br>이 경우 가장자리 배열을 비워 두십시오.
** 가장자리 [가장자리] ** | | 배열 | 순서를 이행하기 위해 가로지는 가장자리 객체의 배열. <br> 하나의 노드는 유효한 순서로 충분합니다. <br>이 경우 가장자리 배열을 비워 두십시오.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 노드 ** {| | JSON 객체 |
nodeid | | 문자열 | 고유 한 노드 식별
시퀀스 | | UINT32 | 순서대로 노드와 가장자리 시퀀스를 추적하고 주문 업데이트를 단순화하는 번호. <br> 주요 목적은 하나의 OrderID 내에서 두 번 이상 전달되는 노드를 구별하는 것입니다. <br> 가변 시퀀스는 동일한 순서의 모든 노드와 가장자리에 걸쳐 실행되며 새 OrderID가 발행 될 때 재설정됩니다.
* NODEDESCRIPTION* | | 문자열 | 노드에 대한 추가 정보
릴리스 | | 부울 | "True"는 노드가베이스의 일부임을 나타냅니다. <br> "false"는 노드가 수평선의 일부임을 나타냅니다.
*** nodeposition *** | | JSON 객체 | 노드 위치. <br> 노드 위치가 필요하지 않은 차량 유형 (예 : 라인 유도 차량)의 옵션.
** 행동 [action] ** <br>} | | 배열 | 노드에서 실행할 작업 배열. <br> 비어있는 배열, 조치가 필요하지 않은 경우.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** nodeposition ** {| | JSON 객체 | 글로벌 프로젝트 별 세계 좌표 시스템에서지도의 위치를 ​​정의합니다. <br> 각 층에는 자체지도가 있습니다. <br> 모든지도는 동일한 프로젝트 별 글로벌 원점을 사용해야합니다.
x | m | float64 | 맵의 x- 위치 맵 좌표계를 참조하십시오. <br> 정밀도는 특정 구현에 달려 있습니다.
y | m | float64 | 맵 좌표계를 참조하여 맵의 y-position. <br> 정밀도는 특정 구현에 달려 있습니다.
* theta* | rad | float64 | 범위 : [-pi ... pi] <br> <br> 노드에서 AGV의 절대 방향. <br> 선택 사항 : 차량 자체로 경로를 계획 할 수 있습니다. <br> 정의 된 경우, AGV는이 노드의 theta 각도를 가정해야합니다. <br> 이전 에지가 회전하면 Node에서 AGV가 회전해야합니다. 가장자리로 들어가기 전에 노드에서 원하는 가장자리로 회전하십시오.
* enverdeviationXy* | m | float64 | AGV가 통과 된 것으로 간주되도록 노드의 위치와 정확히 일치 해야하는지를 나타냅니다. <br> <br> if = 0.0 : 편차가 허용되지 않습니다 (AGV 제조업체의 정상 공차 내에서 편차는 없음). <br> <br> if> 0.0 : 미터의 편차 반경이 허용됩니다. <br> AGV가 편차 반경 내에서 노드를 통과하면 노드는 트래버스로 간주 될 수 있습니다.
* enverdeviationTha* | rad | float64 | 범위 : [0.0 ... pi] <br> <br> theta에 정의 된 방향이 AGV에 의해 노드에서 얼마나 정확한지를 나타냅니다. <br> 허용되는 가장 낮은 각도는 theta -enverdeviationtheta이며 허용되는 가장 높은 각도는 theta + enverdeviationtheta입니다.
Mapid | | 문자열 | 위치가 참조되는지도의 고유 식별. <br> 각지도는 동일한 프로젝트 별 조정 원점을 가지고 있습니다. <br> AGV가 엘리베이터를 사용하는 경우 (예 : 출발 바닥에서 대상 바닥으로 이어지면 출발 바닥의지도에서 사라지고 대상 바닥지도의 관련 리프트 노드에서 스폰됩니다.
* mapdescription* <br>} | | 문자열 | 지도에 대한 추가 정보.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 액션 ** {| | JSON 객체 | AGV가 수행 할 수있는 동작을 설명합니다.
ActionType | | 문자열 | "조치 및 매개 변수"의 첫 번째 열에 설명 된 행동 이름. <br> 행동의 기능을 식별합니다.
ActionId | | 문자열 | 동작을 식별하고 주 상태의 ActionState에 매핑하는 고유 한 ID. <br> 제안 : uuids를 사용하십시오.
* ActionDescription* | | 문자열 | 행동에 대한 추가 정보
BlockingType | | 문자열 | enum { 'none', 'soft', 'hard'} : <br> 'none': 운전 및 기타 행동을 허용합니다. <br> '소프트': 다른 행동을 허용하지만 운전하지는 않지만 '하드': 당시 유일하게 허용되는 조치입니다.
*** ActionParameters [ActionParameter] *** <br> <br>} | | 배열 | ACTION의 배열 ACTIONPARAMETER 객체는 표시된 동작에 대한 객체, 예를 들어 "DeviceID", "LoadID", "외부 트리거"입니다. <br> <br> 예제 구현은 [7.2 형식의 매개 변수] (#72- 파라미터)로 찾을 수 있습니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 가장자리 ** {| | JSON 객체 | 두 노드 사이의 방향 연결.
Edgeid | | 문자열 | 고유 한 에지 식별.
시퀀스 | | UINT32 | 순서대로 노드와 가장자리 시퀀스를 추적하고 주문 업데이트를 단순화하는 번호. <br> 가변 시퀀스는 동일한 순서의 모든 노드와 가장자리에 걸쳐 실행되며 새 OrderID가 발행 될 때 재설정됩니다.
* edgedescription* | | 문자열 | 가장자리에 대한 추가 정보.
릴리스 | | 부울 | "True"는 가장자리가베이스의 일부임을 나타냅니다. <br> "False"는 가장자리가 수평선의 일부임을 나타냅니다. 
STARTNODEID | | 문자열 | 순서 내에서 첫 번째 노드의 Nodeid.
endnodeid | | 문자열 | 순서 내의 마지막 노드의 노드 디드.
* MaxSpeed* | m/s | float64 | 가장자리에서 최대 속도가 허용됩니다. <br> 속도는 차량의 가장 빠른 측정으로 정의됩니다.
* Maxheight* | m | float64 | 하중을 포함하여 가장자리의 최대 높이가 허용됩니다.
* MinHeight* | m | float64 | 가장자리에서 하중 처리 장치의 최소 높이.
* 방향* | rad | float64 | 가장자리에 AGV의 방향. 값`OrientationType`은 글로벌 프로젝트 별 맵 좌표 시스템에 비해 해석되어야하는지 또는 가장자리에 접선이 있는지 정의합니다. 가장자리에 대한 접선 해석의 경우 0.0은 앞으로 운전하는 것을 나타내고 PI는 거꾸로 운전하는 것을 나타냅니다. <br> 예 : 오리엔테이션 PI/2 RAD는 90 도의 회전으로 이어질 것입니다. <br> <br> AGV가 다른 방향으로 시작되면``rotationallowed`가 "true"로 설정된 경우 가장자리의 차량을 원하는 방향으로 회전 시키면 <br>``rotationallowed`가 "거짓"이라면, 가장자리를 입력하기 전에 <br> <br> <br> <br> <br> <br> <br> 궤적이 정의되고, 가장자리의 두 연결 노드 사이의 직접 경로에 회전을 적용합니다. <br> 궤적이 가장자리에 정의되면 방향을 궤적에 적용하십시오.
* OrientationType* | | 문자열 | enum { 'global', 'tangection'} : <br> 'global': 글로벌 프로젝트 별 맵 좌표계와 관련하여; <br> '접선': 가장자리에 접선. <br> <br> 정의되지 않으면 기본값은 '탄탄한'입니다.
* 방향* | | 문자열 | 라인 가이드 또는 와이어 가이드 차량에 대한 접점에서 방향을 설정하여 처음에는 정의됩니다 (차량-개별). <br> 예 : "왼쪽", "오른쪽", "직선".
* Rotationallowed* | | 부울 | "true": 회전이 가장자리에서 허용됩니다. <br> "false": 가장자리에서 회전이 허용되지 않습니다. <br> <br> 옵션 : <br> 설정이 없으면 제한 없음.
* maxrotationspeed* | rad/s | float64 | 최대 회전 속도 <br> <br> 선택 사항 : <br> 제한 없음, 설정되지 않은 경우 제한 없음.
*** 궤적 *** | | JSON 객체 | 이 가장자리에 대한 궤적 json 물체는 urburs입니다. <br> AGV가 시작 노드와 가장자리의 끝 노드 사이를 이동 해야하는 경로를 정의합니다. <br> <br> 옵션 : <br> AGV가 궤적을 처리 할 수 ​​없거나 AGV가 자체 궤적을 계획하는 경우 생략 할 수 있습니다.
* 길이* | m | float64 | 시작 노드에서 끝 노드까지의 경로의 길이 <br> <br> 선택 사항 : <br>이 값은 라인 유도 AGV에 의해 사용하여 정지 위치에 도달하기 전에 속도를 줄입니다.
*** 복도 *** | | JSON 객체 | 차량이 장애물을 피하기 위해 차량이 궤적에서 벗어날 수있는 경계의 정의. <br>
** 액션 [액션] ** <br> <br> <br>} | | 배열 | 가장자리에서 실행될 작업 배열. <br> 비어있는 배열, 조치가 필요하지 않은 경우. <br> Edge에 의해 트리거 된 동작은 AGV가 동작을 트리거하는 가장자리를 가로 지르는 시간 동안 만 활성화됩니다. <br> AGV가 가장자리를 떠나면 동작이 멈추고 가장자리에 들어가기 전에 상태가 회복됩니다.


객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 궤적 ** {| | JSON 객체 |
학위 | | float64 | 범위 : [1.0 ... float64.max] <br> <br> 궤적을 정의하는 멍청한 곡선의 정도. <br> <br> 정의되지 않으면 기본값은 1입니다.
** KnotVector [float64] ** | | 배열 | 범위 : [0.0 ... 1.0] <br> <br> nurbs의 매듭 값 배열. <br> <br> Knotvector는 제어점의 크기 + 학위 + 1입니다.
** ControlPoints [ControlPoint] ** <br> <br>} | | 배열 | 출발 및 종말점을 포함하여 명시 적으로 NURB의 제어점을 정의하는 Control Point 객체 배열.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** ControlPoint ** {| | JSON 객체 |
x | | float64 | 세계 좌표계에서 설명 된 X- 코디네이션.
y | | float64 | 세계 좌표계에서 설명 된 y 좌표.
* 무게* | | float64 | 범위 : [0.0 ... float64.max] <br> <br> 곡선의 제어점의 무게. <br> 정의되지 않으면 기본값은 1.0이됩니다.
} | | |

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
*** 복도 *** {| | JSON 객체 |
LEFTWIDTH | m | float64 | 범위 : [0.0 ... float64.max] <br> 차량의 궤적과 관련하여 왼쪽으로 복도의 너비를 정의합니다 (그림 13 참조).
Rightwidth | m | float64 | 범위 : [0.0 ... float64.max] <br> 차량의 궤적과 관련된 오른쪽으로 복도의 너비를 정의합니다 (그림 13 참조).
*CorridorRefPoint*<br> <br> **} ** | | 문자열 | 경계가 운동 학적 중심에 유효한 지 또는 차량의 윤곽 여부를 정의합니다. 지정되지 않은 경우 경계는 차량 운동 중심에 유효합니다. <br> enum { 'kinematiccenter', 'Contour'}

### 6.7 맵

다양한 유형의 AGV간에 일관된 내비게이션을 보장하기 위해, 위치는 항상 프로젝트 별 좌표계와 관련하여 지정됩니다 (그림 11 참조).
다른 수준의 사이트 또는 위치 간의 차별화를 위해 고유 한 'MAPID'가 사용됩니다.
맵 좌표계는 z 축이 하늘을 향한 오른 손잡이 좌표 시스템으로 지정됩니다.
따라서 양의 회전은 반 시계 방향 회전으로 이해되어야한다.
차량 좌표계는 또한 X 축이 차량의 전방 방향을 가리키고 Z 축이 위쪽을 가리키는 오른 손잡이 좌표계로 지정됩니다. 차량 기준점은 달리 지정되지 않는 한 차량 기준 프레임에서 (0,0,0)으로 정의됩니다.
이것은 DIN ISO 8855의 2.11 절에 따른 것입니다.

![그림 11 샘플 AGV 및 방향이있는 좌표 시스템](./assets/coordinate_system_vehicle_orientation.png)
> 그림 11 샘플 AGV 및 방향이있는 좌표계

X, Y 및 Z 좌표는 미터로 제공되어야합니다. 
방향은 라디안에 있어야하며 +pi 및 –pi 내에 있어야합니다.

![그림 12지도 및 차량의 좌표 시스템](./assets/coordinate_system_vehicle_map.png)
> 그림 12지도 및 차량 용 좌표계


### 6.7.1지도 배포

필요한 경우 차량을 다시 시작할 수있는 자동 맵 배포 및 지능형 관리를 가능하게하려면 맵을 배포하는 표준화 된 방법이 도입됩니다.

배포 할지도 파일은 차량에서 액세스 할 수있는 전용지도 서버에 저장됩니다. 효율적인 전송을 보장하기 위해 각 전송은 단일 파일로 구성되어야합니다. 여러 맵이나 파일이 필요한 경우 번들 또는 단일 파일로 포장해야합니다. 맵 서버에서 차량으로 맵을 전송하는 프로세스는 'instantAction'을 사용하여 다운로드 명령을 트리거하는 마스터 컨트롤에 의해 시작된 풀 작동입니다.
각 맵은 맵 식별자 (필드`mapid`)와 맵 버전 (필드`mapversion`)의 조합으로 고유하게 식별됩니다. 맵 식별자는 차량의 실제 작업 공간의 특정 영역을 설명하고 맵 버전은 이전 버전에 대한 업데이트를 나타냅니다. 새 주문을 수락하기 전에 차량은 요청 된 주문의 차량에 차량에지도가 있는지 확인해야합니다. 차량을 작동시키기 위해 올바른 맵이 활성화되도록하는 것은 마스터 컨트롤의 책임입니다.

다운 타임을 최소화하고 마스터 컨트롤이 새 맵의 활성화를 더 쉽게 동기화 할 수 있도록하려면 차량에 맵이 사전로드 또는 버퍼링되는 것이 중요합니다. 차량의지도 상태는 차량 상태 채널을 통해 액세스 할 수 있습니다. 맵을 AGV로 전송 한 다음 맵을 활성화하는 것은 다른 프로세스라는 점에 유의해야합니다. 차량에서 사전로드 된 맵을 활성화하려면 마스터 컨트롤은 즉각적인 조치를 보냅니다. 이 경우 동일한 맵 식별자이지만 다른 맵 버전이 자동으로 비활성화 된 다른 맵이 있습니다. 다른 즉각적인 동작으로 마스터 컨트롤로 맵을 삭제할 수 있습니다. 이 과정의 결과는 차량 상태에 표시됩니다.

맵 분포 프로세스는 그림 13에 나와 있습니다.

![그림 13 맵 분배 프로세스](./assets/map_distribution_process.png)
> 그림 13 마스터 컨트롤, AGV 및 MAP 서버 간의 통신이 필요합니다.

#### 6.7.2 차량 상태의지도

상태의 'AgvPosition'에있는 'mapid'필드는 현재 활성지도를 나타냅니다. 차량에서 사용 가능한지도에 대한 정보는 상태 메시지의 구성 요소 인 '맵'배열에 나와 있습니다. 이 배열의 각 항목은 'mapid`,'mapversion` 및 'mapstatus'로 구성된 필드 필드로 구성된 JSON 객체입니다. 필요한 경우 차량에서 '활성화'맵을 사용할 수 있습니다. '비활성화 된'지도는 사용되지 않아야합니다. 다운로드 프로세스의 상태는 현재 작업이 완료되지 않은 것으로 표시됩니다. 오류는 주에서도보고됩니다.

'MAPID'가 다른 다중 맵을 동시에 활성화 할 수 있습니다. 한 번에 동일한`mapid '가 활성화 된 맵의 맵 버전 만있을 수 있습니다. `맵 '배열이 비어있는 경우, 이는 현재 차량에 사용할 수있는지도가 없음을 의미합니다.


#### 6.7.3지도 다운로드

지도 다운로드는 마스터 컨트롤의 'DownloadMap` 인스턴트 조치에 의해 트리거됩니다. 이 명령에는 맵이 맵 서버에 저장되고 차량에서 액세스 할 수있는 필수 매개 변수`mapid` 및 'mapdownloadlink'가 포함되어 있습니다.

AGV는 맵 파일 다운로드를 시작하자마자`actionstatus`를 '실행'으로 설정합니다. 다운로드가 성공하면`ActionStatus '가'완료 '로 업데이트됩니다. 다운로드가 실패하면 상태가 '실패'로 설정됩니다. 다운로드가 성공적으로 완료되면지도는 주에서 '맵'배열에 추가됩니다. 지도는 활성화 될 준비가되기 전에 주에서보고되지 않아야합니다.

맵 다운로드 프로세스가 차량의 기존 맵을 수정, 삭제, 활성화 또는 비활성화하지 않도록하는 것이 중요합니다.
차량은 이미 차량에있는 'Mapid'와 'mapversion'이있는지도의 다운로드를 거부해야합니다. 오류 가보고되어야하며 즉각적인 조치의 상태는 '실패'로 설정되어야한다. 마스터 컨트롤은 먼저 차량의 맵을 삭제 한 다음 다운로드를 다시 시작해야합니다.


#### 6.7.4 다운로드 맵 활성화

차량에서지도를 활성화하는 두 가지 방법이 있습니다.

1. ** 마스터 컨트롤은 맵 ** : 'enablemap` 인스턴트 동작을 사용하여 차량에서'enabled '에지도를 설정하십시오. 다른 'mapversion'을 사용한 동일한`mapid '의 다른 버전은'비활성화 '로 설정됩니다.
2. ** 수동으로 차량에지도를 활성화 ** : 경우에 따라 차량의지도를 직접 활성화해야 할 수도 있습니다. 결과는 차량 상태에서보고되어야한다.

'nodeposition'의 일부로 해당 'MAPID'를 보낼 때 차량에서 올바른지도가 활성화되도록하는 것은 마스터 컨트롤의 책임입니다.
차량을 새 맵에서 특정 위치로 설정하려면`intosposition 'Instant 동작이 사용됩니다.


#### 6.7.5 차량의지도를 삭제합니다
마스터 컨트롤은 차량에서 특정지도를 삭제할 수 있습니다. 이것은 즉각적인 동작 'deletemap'으로 이루어집니다. 차량에 메모리가 부족하면 마스터 컨트롤에이를보고해야하며지도 삭제를 시작할 수 있습니다. 차량 자체는 맵을 삭제할 수 없습니다.
맵을 성공적으로 삭제 한 후 차량 상태의 차량의 맵 배열에서 해당지도 항목을 제거하는 것이 중요합니다.


## 6.8 행동
AGV가 운전 이외의 동작을 지원하는 경우, 이러한 동작은 노드 또는 에지에 첨부 된 작업 필드를 통해 실행되거나 별도의 주제 'InstantAction'(섹션 [6.10 주제 "InstantAction"참조] (#610 주제-인스턴트 액션 -Master-Control-to-AGV)을 통해 전송됩니다.

Edge에서 실행될 조치는 AGV가 가장자리에있는 동안에 만 실행됩니다 (섹션 [6.11.2 노드의 트래버스 및 가장자리에 들어가기/떠나기] (#6112-traversal of nodesing and-entering-edges-trigger-of-accaction) 참조).

노드에서 트리거되는 동작은 실행 해야하는 한 실행될 수 있으며 자체 정기 (예 : 5 초 동안 지속되는 오디오 신호 또는 하중을 선택한 후 완료된 오디오 신호) 또는 쌍을 방해하는 (예 : 활성화 조명”및 "DeactivateWarninglights") (예 : 예외가있을 수 있음).

다음 섹션에서는 AGV의 기능이 작업 설명에 맵핑되는 경우 AGV가 사용해야 할 사전 정의 된 작업을 제시합니다.
정의 된 매개 변수를 사용하는 현명한 방법이있는 경우 사용해야합니다.
작업을 성공적으로 실행 해야하는 경우 추가 매개 변수를 정의 할 수 있습니다.

다음 섹션의 조치 중 하나에 어떤 조치를 매핑 할 방법이없는 경우, AGV 제조업체는 마스터 제어에서 사용할 추가 작업을 정의 할 수 있습니다.


### 6.8.1 사전 정의 된 조치의 정의, 매개 변수, 효과 및 범위

일반 | | 범위
: --- : | --- | : --- :
조치, 카운터 조치, 설명, idempotent, 매개 변수 | 연결된 상태 | 즉각, 노드, 모서리

행동 | 카운터 액션 | 설명 | Idempotent | 매개 변수 | 연결된 상태 | 즉석 | 노드 | 가장자리
--- | --- | --- | --- | --- | --- | --- | --- | --- | ---
StartPause | STOPPAUSE | 일시 중지 모드를 활성화합니다. <br> 하드웨어 스위치를 사용하여 많은 AGV를 일시 중지 할 수 있기 때문에 연결된 상태가 필요합니다. <br> 더 이상 AGV 운전 이동 - 다음 노드에 도달 할 필요는 없습니다. <br> 동작은 계속 될 수 있습니다. <br> 주문이 재개 될 수 있습니다. | 예 | - | 일시 중지 | 예 | 아니요 | 아니요
STOPPAUSE | StartPause | 일시 정지 모드를 비활성화합니다. <br> 이동 및 기타 모든 작업이 재개됩니다 (있는 경우) <br> 하드웨어 스위치를 사용하여 많은 AGV를 일시 중지 할 수 있기 때문에 연결된 상태가 필요합니다. <br> stopPause는 또한 startPause (구성된 경우)를 트리거 한 하드웨어 버튼으로 정지 된 차량을 다시 시작할 수도 있습니다. | 예 | - | 일시 중지 | 예 | 아니요 | 아니요
시작 차지 | 스톱 숯 | 충전 프로세스를 활성화합니다. <br> 충전 지점 (차량 스탠딩) 또는 충전 차선 (운전 중)에서 충전을 수행 할 수 있습니다. <br> 과충전에 대한 보호는 차량의 책임입니다. | 예 | - | .Batterystate.CHARGING | 예 | 예 | 아니요
스톱 숯 | 시작 차지 | 충전 프로세스를 비활성화하여 새 주문을 보냅니다. <br> 차량 / 충전 스테이션 (예 : 배터리가 가득 차면 차량 / 충전소에 의해 충전 프로세스를 중단 할 수도 있습니다. <br> 배터리 상태는 AGV가 주문을받을 준비가되었을 때만 "거짓"으로 만 허용됩니다. | 예 | - | .batterystate.charging | 예 | 예 | 아니요
초기 위치 | - | 주어진 매개 변수로 AGV의 포즈를 재설정 (재정의). | 예 | x (float64) <br> y (float64) <br> theta (float64) <br> mapid (string) <br> lastnodeid (string) | .AgvPosition.x <br> .AgvPosition.y <br> .AgvPosition.theta <br> .agvposition.mapid <br> .lastnodeid <br> .maps | 예 | 예 <br> (엘리베이터) | 아니요
enablemap | - | 새 위치를 초기화하지 않고도 이전에 다운로드 한 맵을 명시 적으로 사용하도록 주문하십시오. | 예 | mapid (string) <br> mapversion (String) | .maps | 예 | 예 | 아니요
다운로드 맵 | - | 새지도의 다운로드를 트리거하십시오. 다운로드 중에 활성화됩니다. 차량 상태에서보고 된 오류. 성공적인 다운로드를 확인하고, 사용을위한지도를 준비하고 주에서지도를 설정 한 후 완료되었습니다. | 예 | mapid (string) <br> mapversion (string) <br> mapdownloadlink (String) <br> maphash (String, 옵션) | .maps | 예 | 아니요 | 아니요
deletemap | - | 차량 메모리에서 맵을 제거합니다. | 예 | mapid (string) <br> mapversion (String) | .maps | 예 | 아니요 | 아니요
STATEREQUEST | - | AGV에 새로운 주 보고서를 보내도록 요청합니다. | 예 | - | - | 예 | 아니요 | 아니요
logreport | - | AGV가 로그 보고서를 생성하고 저장하도록 요청합니다. | 예 | 이유 <br> (문자열) | - | 예 | 아니요 | 아니요
선택 | <br> <br> (자동화 된 경우) | AGV에 부하를 선택하도록 요청하십시오. <br> 여러로드 처리 장치가있는 AGV는 여러 픽 작업을 병렬로 처리 할 수 ​​있습니다. <br>이 경우 매개 변수 LHD가 존재해야합니다 (예 : LHD1). <br> 파라미터 Stattype는 픽 작업이 어떻게 처리되는지 (예 : 바닥 위치, 랙 위치, 패시브 컨베이어, 활성 컨베이어 등)를 알려줍니다. <br>로드 유형은로드 장치에 대해 알려주고 예를 들어 필드를 전환하는 데 사용될 수 있습니다 (예 : Epal, Indu 등). <br>로드 처리 장치를 준비하기 위해 (예 : 높이 매개 변수를 기반으로 한 미리 리프트 조작) 작업을 사전에 발표 할 수 있습니다. <br> 그러나 프리 리프트 작업 등은 AGV 상태에서 '실행'으로보고되지 않습니다. 관련 노드는 아직 해제되지 않았기 때문에. <br> 가장자리에있는 경우, 차량은 감지 장치를 사용하여 노드를 선택할 수있는 위치를 감지 할 수 있습니다. | no | lhd (string, 옵션) <br> statttype (문자열) <br> stationname (문자열, 선택적) <br> loadtype (string) <br> loadid (string, 옵션) <br> 높이 (float64) <br> 바닥과 관련된 하중의 하단 <br> 깊이 (float64) (옵션) (stript) (string) (string) (string) (옵션). | .LOAD | 아니요 | 예 | 예
드롭 | 선택 <br> <br> (자동화 된 경우) | AGV에 부하를 삭제하도록 요청하십시오. <br> 자세한 내용은 액션 선택을 참조하십시오. | 아니요 | lhd (문자열, 선택적) <br> statttype (문자열, 선택적) <br> stationname (문자열, 옵션) <br> loadtype (문자열, 옵션) <br> loadid (문자열, 옵션) <br64, 옵션) <br> 깊이 (float64, 옵션) <br>… | .LOAD | 아니요 | 예 | 예
DetectObject | - | AGV는 물체를 감지합니다 (예 : 하중, 충전 지점, 무료 주차 위치). | 예 | ObjectType (문자열, 선택 사항) | - | 아니요 | 예 | 예
미세 위치 | - | 노드에서 AGV는 대상에 정확히 배치됩니다. <br> AGV는 노드 위치에서 벗어날 수 있습니다. <br> 가장자리에서 AGV는 예를 들어 고정 장비에 정렬하면서 가장자리를 가로 지르면됩니다. <br> 인스턴트 액션 : AGV는 대상에 정확히 위치를 시작합니다. | 예 | statttype (문자열, 선택 사항) <br> stationname (문자열, 선택 사항) | - | 아니요 | 예 | 예
WaitforTrigger | - | AGV는 AGV에서 트리거를 기다려야합니다 (예 : 버튼 프레스, 수동 로딩). <br> 마스터 컨트롤은 타임 아웃을 처리 할 책임이 있으며 필요한 경우 주문을 취소해야합니다. | 예 | 트리거 타입 (문자열) | - | 아니요 | 예 | 아니요
CancelOrder | - | AGV는 가능한 빨리 멈 춥니 다. <br> 이것은 즉시 또는 다음 노드에있을 수 있습니다. <br> 그러면 주문이 삭제됩니다. 모든 조치가 취소됩니다. | 예 | - | - | 예 | 아니요 | 아니요
FactSheetRequest | - | AGV가 사실 시트를 보내도록 요청합니다 | 예 | - | - | 예 | 아니요 | 아니요


### 6.8.2 사전 정의 된 조치의 상태

행동 | 행동 상태
--- | : --- :
 | | '초기화', '실행', '일시 정지', '완성', '실패'|

행동 | '초기화'| '달리기'| '일시 정지'| '완료'| '실패한'
--- | --- | --- | --- --- | --- | ---
StartPause | - | 모드의 활성화는 준비 중입니다. <br> AGV가 즉각적인 전환을 지원하는 경우이 상태를 생략 할 수 있습니다. | - | 차량은 여전히 ​​서 있습니다. <br> 모든 조치는 일시 중지됩니다. <br> 일시 중지 모드가 활성화됩니다. <br> AGV는 .paued : "true"를보고합니다. | 일시 정지 모드는 어떤 이유로 든 (예 : 하드웨어 스위치로 재정의) 활성화 할 수 없습니다.
STOPPAUSE | - | 모드의 비활성화가 준비 중입니다. <br> AGV가 즉각적인 전환을 지원하면이 상태를 생략 할 수 있습니다. | - | 일시 정지 모드가 비활성화됩니다. <br> 모든 일시 정지 조치가 재개됩니다. <br> AGV가 .Paued : "false"를보고합니다. | 일시 정지 모드는 어떤 이유로 든 비활성화 될 수 없습니다 (예 : 하드웨어 스위치에 의해 덮어 쓴).
시작 차지 | - | 충전 프로세스의 활성화가 진행 중입니다 (충전기와의 통신이 실행 중). <br> AGV가 즉각적인 전환을 지원하면이 상태를 생략 할 수 있습니다. | - | 충전 프로세스가 시작됩니다. <br> AGV 보고서 .batterystate.charging : "true". | 충전 프로세스는 어떤 이유로 든 (예 : 충전기에 정렬되지 않음)를 시작할 수 없었습니다. 충전 문제는 오류와 일치해야합니다.
스톱 숯 | - | 충전 프로세스의 비활성화가 진행 중입니다 (충전기와의 통신이 실행 중). <br> AGV가 즉각적인 전환을 지원하면이 상태를 생략 할 수 있습니다. | - | 충전 프로세스가 중지됩니다. <br> AGV 보고서 .batterystate.charging : "false"| 충전 프로세스는 어떤 이유로 든 중지 될 수 없습니다 (예 : 충전기에 정렬되지 않음). <br> 충전 문제는 오류와 일치해야합니다.
초기 위치 | - | 새로운 포즈의 초기화 진행 중입니다 (신뢰 점검 등). <br> AGV가 즉각적인 전환을 지원하면이 상태를 생략 할 수 있습니다. | - | 포즈가 재설정됩니다. <br> AGV 보고서 <br> .agvposition.x = x, <br> .AgvPosition.y = y, <br> .AgvPosition.theta = theta = theta = theta = theta = theta = theta <br> .AgvPosition.mapid = mapid <br> .gvposition.lastnodeid = lastNodeid | 자세는 유효하지 않거나 재설정 할 수 없습니다. <br> 일반적인 현지화 문제는 오류와 일치해야합니다.
| 다운로드 맵 | 맵 서버에 대한 연결을 초기화하십시오. | AGV는 다운로드가 완료 될 때까지지도를 다운로드합니다. | - | AGV는 MAPID/MAPVERSION 및 해당 MAPSTATUS를 '비활성화'로 설정하여 상태를 업데이트합니다. | 다운로드가 실패하고 차량 상태로 업데이트되었습니다 (예 : Connection Lost, MAP 서버는지도 서버에 존재하지 않는 MAPID/MAPVERSION). |
| enablemap | - | AGV는 요청 된 MAPID 및 MAPVERSION으로 맵을 활성화하면서 동일한 MAPID로 다른 버전을 비활성화합니다. | - | AGV는 요청 된 맵의 해당 MapStatus를 'enabled'로, 다른 버전은 '비활성화'와 동일한 MAPID를 업데이트합니다. | 요청 된 mapid/mapversion 조합이 존재하지 않습니다. |
| deletemap | - | AGV는 내부 메모리에서 요청 된 MAPID 및 MAPVERSION으로 맵을 삭제합니다. | - | AGV는 상태에서 MAPID/MAPVERSION을 제거합니다. | 맵이 현재 사용중인 경우 맵을 삭제할 수 없습니다. 요청 된 MAPID/MAPVERSION 조합은 이미 전에 삭제되었습니다. |
STATEREQUEST | - | - | - | 국가는 전달되었습니다 | -
logreport | - | 보고서는 생성 중입니다. <br> AGV가 즉각적인 세대를 지원하는 경우이 상태를 생략 할 수 있습니다. | - | 보고서가 저장됩니다. <br> 로그 이름은 상태에보고됩니다. | 보고서를 저장할 수 없습니다 (예 : 공간 없음).
선택 | 예를 들어 픽 프로세스 초기화 (예 : 미결 리프트 작업). | 픽 프로세스가 실행 중입니다 (AGV는 스테이션으로 이동하고,로드 처리 장치가 바쁘고, 스테이션과의 통신이 실행 중입니다)). | 예를 들어 안전 분야가 위반되는 경우 픽 프로세스가 일시 중지됩니다. <br> 위반을 제거한 후 픽 프로세스가 계속됩니다. | 선택이 완료되었습니다. <br>로드가 AGV에 들어 갔으며 AGV는 새로운 부하 상태를보고했습니다. | 예를 들어 스테이션이 예상치 못한 비어 있습니다. <br> 실패한 선택 작업은 오류와 일치해야합니다.
드롭 | 드롭 프로세스의 초기화 (예 : 미결 리프트 작업). | 드롭 프로세스가 실행 중입니다 (AGV는 스테이션으로 이동하고,로드 처리 장치가 바쁘고, 스테이션과의 통신이 실행 중입니다). | 예를 들어 안전 분야가 위반되는 경우 드롭 프로세스가 일시 중지됩니다. <br> 위반을 제거한 후 드롭 프로세스가 계속됩니다. | 드롭이 완료되었습니다. <br>로드는 AGV를 떠났고 AGV는 새로운 부하 상태를보고했습니다. | 예를 들어 스테이션이 예상치 못한 점유 된 드롭이 실패했습니다. <br> 실패한 드롭 작업은 오류와 일치해야합니다.
DetectObject | - | 객체 감지가 실행 중입니다. | - | 물체가 감지되었습니다. | AGV는 물체를 감지 할 수 없었습니다.
미세 위치 | - | AGV는 대상에 정확하게 위치합니다. | 예를 들어 안전 분야가 위반되는 경우 미세 포지셔닝 프로세스가 일시 중지됩니다. <br> 위반을 제거한 후 정밀 포지셔닝이 계속됩니다. | 스테이션을 참조하는 목표 위치에 도달합니다. | 스테이션을 참조하는 목표 위치에 도달 할 수 없습니다.
WaitforTrigger | - | AGV는 방아쇠를 기다리고 있습니다 | - | 트리거가 트리거되었습니다. | 주문이 취소 된 경우 WaitforTrigger가 실패합니다.
CancelOrder | - | AGV는 다음 노드에 도달 할 때까지 멈추거나 운전합니다. | - | AGV는 여전히 서서 주문을 취소했습니다. | -
FactSheetRequest | - | - | - | 팩트 시트는 전달되었습니다 | -


## 6.9 주제 : "Instantactions"(마스터 컨트롤에서 AGV까지)

경우에 따라 즉시 수행 해야하는 AGV에 조치를 보내야합니다.
이것은 'InstantAction'메시지를 'InstantAction'주제에 게시함으로써 가능합니다.
이들은 AGV의 현재 순서의 내용과 충돌하지 않아야한다 (예 : '인스턴스 션'은 포크를 낮추고, 주문은 포크를 높이라고 말한다).

즉각적인 행동이 관련 될 수있는 몇 가지 예는 다음과 같습니다.
- 현재 순서로 아무것도 변경하지 않고 AGV를 일시 중지하십시오.
- 일시 중지 후 주문 재개;
- 신호 (광학, 오디오 등)를 활성화합니다.

추가 정보는 섹션 [7 모범 사례] (#7-best-actice)을 참조하십시오.

객체 구조 | 데이터 유형 | 설명
--- | --- | ---
Headerid | UINT32 | 메시지의 헤더 ID. <br> 헤더 ID는 주제별로 정의되며 전송 된 각각 (반드시 수신 할 필요는 없지만)마다 1으로 증가합니다.
타임 스탬프 | 문자열 | 타임 스탬프 (ISO 8601, UTC); yyyy-mm-ddthh : mm : ss.ffz (예 : "2017-04-15t11 : 40 : 03.12z")
버전 | 문자열 | 프로토콜의 버전 [major]. [minor]. [patch] (예 : 1.3.2).
제조업체 | 문자열 | AGV의 제조업체.
SerialNumber | 문자열 | AGV의 일련 번호.
행동 [행동] | 배열 | 즉시 수행해야하고 정기적 인 순서의 일부가 아닌 조치 배열.

AGV가 'instantAction'을 받으면 AGV 상태의 'ActionStates'배열에 적절한 'ActionStatus'가 추가됩니다.
'ActionStatus'는 작업의 진행 상황에 따라 업데이트됩니다.
'ActionStatus'의 다양한 전환은 그림 16을 참조하십시오.


## 6.10 주제 : "State"(AGV에서 마스터 컨트롤까지)

AGV 상태는 하나의 주제로만 전송됩니다.
하나의 주제를 사용하는 별도의 메시지 (예 : 주문, 배터리 상태 및 오류)와 비교하면 중개인의 워크로드와 메시지 처리를위한 마스터 컨트롤이 줄어들면서 AGV 상태에 대한 정보를 동기화합니다.

AGV 상태 메시지는 관련 이벤트가 발생하거나 MQTT 브로커를 통해 최신 30 대를 마스터하여 제어 할 수 있습니다.

상태 메시지의 전송을 유발하는 이벤트는 다음과 같습니다.
- 주문 수신
- 주문 업데이트 수신
-로드 상태의 변경
- 오류 또는 경고
- 노드 위로 운전합니다
- 작동 모드를 전환합니다
- '운전'필드의 변경
-`nodestates`,`edgestates` 또는`actionstates '의 변경
- '맵'필드의 변경

의사 소통의 양을 억제하려는 노력이 있어야합니다.
두 이벤트가 서로 관련이있는 경우 (예 : 새 주문을받는 것이 일반적으로 'Nodestates'및 'Edgestates'의 업데이트를 강요합니다.


### 6.10.1 개념 및 논리

주문 진행 상황은`Nodestates`와`Edgestates '에 의해 추적됩니다.
또한 AGV가 현재 위치를 도출 할 수있는 경우 '위치'필드를 통해 위치를 게시 할 수 있습니다.

AGV가 그 자체로 경로를 계획하는 경우, 마스터 통제 가이 필드를 사용할 수없고 통합 중에 합의되지 않았다면, 상태 메시지의 '궤적'대상을 통해 계산 된 궤적 (기본 및 수평선 포함)을 전달 하여이 필드를 보내지 않아야한다.
마스터 컨트롤에 의해 노드를 해제 한 후 AGV는 궤적을 변경할 수 없습니다.

`nodestates '와`edgestates'에는 모든 노드/에지가 포함되어 있으며 AGV는 여전히 가로 질러야합니다.

![그림 14 상태 주제에서 제공 한 주문 정보. 마지막 노드의 ID와 나머지 노드 및 모서리 만 전송됩니다](./assets/order_information_state_topic.png)
> 그림 14 상태 주제에서 제공 한 주문 정보. 마지막 노드의 ID와 나머지 노드 및 모서리 만 전송됩니다.



### 6.10.2 노드의 횡단 및 가장자리 입력/남기, 동작 트리거

AGV는 노드가 트래버스로 계산되어야 할 때 자체적으로 결정합니다.
일반적으로 AGV의 제어 지점은 노드의 '허용 대상'내에 있어야하며`leaintDeviationTha '내의 방향 내에 있어야합니다.
후속 모서리의 가장자리 속성`corridor '가 설정되면 이러한 경계는 추가로 충족되어야합니다.

AGV는`Nodestates '배열에서'Nodestate '를 제거하고'lastnodeid ','lastnodequenceid '를 트래버스 노드의 값으로 설정함으로써 노드의 횡단을보고합니다.

AGV가 노드를 트래버스로보고하자마자 AGV는 노드와 관련된 동작을 트리거해야합니다.

노드의 횡단은 또한 노드로 이어지는 가장자리의 이탈을 표시합니다.
그런 다음 가장자리는 'Edgestates'에서 제거되어야하며 가장자리에서 활성화 된 동작은 완료됩니다.

노드의 횡단은 또한 AGV가 다음 가장자리에 들어가는 순간을 표시합니다.
에지의 행동은 이제 트리거됩니다.
이 규칙에 대한 예외는 AGV가 가장자리에서 일시 중지 해야하는 경우 (부드러운 또는 하드 블로킹 에지로 인해) - AGV가 다시 움직이기 시작한 후 가장자리로 들어갑니다.

!
> 그림 15 주문 처리 중에 'Nodestates', 'Edgestates'및 'ActionStates'의 묘사


### 6.10.3 기본 요청

AGV가 기본이 낮게 작동하는 것을 감지하면 'Newbaserequest` 플래그를 "True"로 설정하여 불필요한 제동을 방지 할 수 있습니다.


### 6.10.4 정보

AGV는 '정보'배열을 통해 마스터 제어에 임의의 추가 정보를 제출할 수 있습니다.
정보 메시지를 통해 정보를보고하는 시간은 AGV에 달려 있습니다.

마스터 컨트롤은 논리에 정보 메시지를 사용하지 않아야하며 시각화 및 디버깅 목적으로 만 사용해야합니다.


### 6.10.5 오류

AGV는 '오류'배열을 통해 오류를보고합니다.
오류는 '경고'와 '치명적'이라는 두 가지 레벨이 있습니다.
'경고'는 자체 분리 오류 (예 : 필드 위반)입니다.
'치명적'오류는 인간의 개입이 필요합니다.
오류는 'ErrorCreences'배열을 통해 오류의 원인을 찾는 데 도움이되는 참조를 전달할 수 있습니다.


### 6.10.6 상태 메시지의 구현

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
Headerid | | UINT32 | 메시지의 헤더 ID. <br> Headerid는 주제별로 정의되며 각각의 전송 된 (그러나 반드시 수신 할 필요는 없지만) 1으로 증가합니다.
타임 스탬프 | | 문자열 | 타임 스탬프 (ISO 8601, UTC); yyyy-mm-ddthh : mm : ss.ffz (예 : "2017-04-15t11 : 40 : 03.12z").
버전 | | 문자열 | 프로토콜의 버전 [major]. [minor]. [patch] (예 : 1.3.2).
제조업체 | | 문자열 | AGV의 제조업체.
SerialNumber | | 문자열 | AGV의 일련 번호.
*지도 [지도]* | | 배열 | 현재 차량에 저장된 맵 객체 배열.
ORDERID | | 문자열 | 현재 주문 또는 이전에 완료된 주문의 고유 주문 식별. <br> OrderID는 새로운 주문이 수신 될 때까지 보관됩니다. <br> 빈 문자열 ( ""), 이전 OrderId를 사용할 수없는 경우.
OrderupDateId | | UINT32 | 주문 업데이트 식별을 확인하여 AGV가 주문 업데이트를 수락했는지 확인하십시오. <br> "0"이전 OrderUpDateId를 사용할 수없는 경우.
* ZonesetId* | | 문자열 | AGV가 현재 경로 계획에 사용하는 구역 세트의 고유 한 ID. <br> 순서대로 사용 된 것과 동일해야합니다. <br> <br> 선택 사항 : AGV가 영역을 사용하지 않으면이 필드를 생략 할 수 있습니다.
LastNodeid | | 문자열 | 마지막으로 도달 한 노드의 노드 ID 또는 AGV가 현재 노드에있는 경우 현재 노드 (예 : "Node7"). `lastnodeid '가없는 경우 빈 문자열 ( "").
LastNodeSequenceId | | UINT32 | 마지막에 도달 한 노드의 시퀀스 ID 또는 AGV가 현재 노드에있는 경우 현재 노드의 시퀀스 ID. <br> "0"`lastnodequenceId '가 없으면 사용할 수 있습니다.
** Nodestates [Nodestate] ** | | 배열 | 순서를 충족시키기 위해 가로 질러야하는 Nodestate 객체의 배열 <br> (유휴 경우 빈 배열)
** edgestates [edgestate] ** | | 배열 | 순서를 충족시키기 위해 가로 질러야하는 대형 객체 배열 <br> (유휴 경우 빈 배열)
*** agvposition *** | | JSON 객체 | 맵에서 AGV의 현재 위치. <br> <br> 선택 사항 : 예를 들어 라인 유도 AGV와 같은 로컬 화 능력없이 AGV에 대해서만 생략 할 수 있습니다.
*** 속도 *** | | JSON 객체 | 차량 좌표의 AGV 속도.
*** 하중 [하중] *** | | 배열 | 현재 AGV에 의해 처리되는로드. <br> <br> 선택 사항 : AGV가 부하 상태를 결정할 수없는 경우이 필드는 완전히 생략되어 빈 배열로보고되지 않아야합니다. <br> AGV가 부하 상태를 결정할 수 있지만 배열이 비어 있으면 AGV는 언로드 된 것으로 간주됩니다.
운전 | | 부울 | "True": AGV가 운전 및/또는 회전하고 있음을 나타냅니다. AGV의 다른 움직임 (예 : 리프트 움직임)은 여기에 포함되지 않습니다. <br> "거짓": AGV가 운전하거나 회전하지 않음을 나타냅니다.
* 일시 중지* | | 부울 | "True": AGV는 현재 AGV의 물리적 버튼을 누르기 때문에 또는 인스턴스 조치로 인해 현재 일시 정지 상태에 있습니다. <br> AGV는 명령을 재개 할 수 있습니다. <br> <br> "false": AGV는 현재 일시 정지 상태에 있지 않습니다.
* Newbaserequest* | | 부울 | "True": AGV는 거의베이스의 끝에 있으며 새로운베이스가 전송되지 않으면 속도를 줄입니다. <br> 마스터 컨트롤이 새로운 기반을 보내기위한 트리거. <br> <br> "false": 기본 업데이트가 필요하지 않습니다.
* DistanceIncelastNode* | 미터 | float64 | 라인 가이드 차량에 의해 사용되는 차량은 마지막 노드를 지나가는 거리를 나타냅니다. <br> 거리는 미터입니다.
** ActionStates [ActionState] ** | | 배열 | 현재 순서의 모든 작업 배열이 포함되어 있으며 마지막 순서 이후로 인스턴스가 수신되었습니다. 행동 상태는 새로운 주문이 접수 될 때까지 보관됩니다. 즉각적인 행동을 제외한 행동 상태는 새로운 주문을 받으면 제거됩니다. <br> 여기에는 아직 진행중인 이전 노드의 작업이 포함될 수 있습니다. <br> <br> 작업이 완료되면 ActionStatus가 '완료'로 설정된 업데이트 된 상태 메시지가 게시되고 해당 결과가 해당 결과를 해당하는 경우에 해당하는 상태 메시지가 게시됩니다.
** 배터리 상태 ** | | JSON 객체 | 모든 배터리 관련 정보가 포함되어 있습니다.
OperatingMode | | 문자열 | Enum { 'Automatic', 'semiautomatic', 'manual', 'service', 'service'} <br> 추가 정보는 섹션 [6.10.6 상태 메시지 구현] (#6106-implementation-of the-the-the-message)을 참조하십시오.
** 오류 [오류] ** | | 배열 | 오류 객체의 배열. <br> AGV의 모든 활성 오류는 배열에 있어야합니다. <br> 빈 배열은 AGV에 활성 오류가 없음을 나타냅니다.
*** 정보 [정보] *** | | 배열 | 정보 객체의 배열. <br> 빈 배열은 AGV에 정보가 없음을 나타냅니다. <br> 이것은 시각화 또는 디버깅에만 사용해야합니다. 마스터 제어의 논리에는 사용되지 않아야합니다.
** 안전 상태 ** | | JSON 객체 | 모든 안전 관련 정보가 포함되어 있습니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
**지도 ** {| | JSON 객체 |
Mapid | | 문자열 | 차량 작업 공간의 정의 된 영역을 설명하는지도의 ID.
MapVersion | | 문자열 | 지도의 버전.
* mapdescription* | | 문자열 | 지도에 대한 추가 정보.
mapstatus <br>} | | 문자열 | enum { 'enabled', 'disabled'} <br> 'enabled':이 맵이 현재 AGV에서 활성화 / 사용되어 있음을 나타냅니다. 동일한 MAPID를 가진 최대 하나의 맵은 해당 상태가 'enabled'로 설정 될 수 있습니다. <br> 'disabled':이 맵 버전은 현재 AGV에서 활성화되지 않았으므로 요청에 따라 활성화 또는 삭제할 수 있음을 나타냅니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** Nodestate ** {| JSON 객체 | |
nodeid | | 문자열 | 고유 한 노드 식별.
시퀀스 | | UINT32 | 동일한 Nodeid로 여러 노드를 식별하는 시퀀스 ID.
* NODEDESCRIPTION* | | 문자열 | 노드에 대한 추가 정보.
릴리스 | | 부울 | "True"는 노드가베이스의 일부임을 나타냅니다. <br> "False"는 노드가 수평선의 일부임을 나타냅니다.
*** nodeposition *** <br> <br>} | | JSON 객체 | 노드 위치. <br> 객체는 [6.6 주제 "Order"] (#66-topic-or-master-control-to-agv) 섹션에 정의되어 있습니다. <br> 옵션 : <br> 마스터 컨트롤에는이 정보가 있습니다. <br>는 예를 들어 디버깅 목적으로 추가로 보낼 수 있습니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** edgestate ** {| | JSON 객체 | |
Edgeid | | 문자열 | 고유 한 에지 식별.
시퀀스 | | UINT32 | 동일한 EdgeID로 여러 모서리를 구별하는 시퀀스 ID.
* edgedescription* | | 문자열 | 가장자리에 대한 추가 정보.
릴리스 | | 부울 | "True"는 가장자리가베이스의 일부임을 나타냅니다. <br> "False"는 가장자리가 수평선의 일부임을 나타냅니다.
*** 궤적 *** <br> <br>} | | JSON 객체 | 궤도는 urburs로 전달되며 주문 메시지의 섹션 [6.6.6 구현] (#666-implementation of the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-message)에 정의되어 있습니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** agvposition ** {| | JSON 객체 | 세계 좌표에서지도의 위치를 ​​정의합니다. 각 층에는 자체지도가 있습니다.
위치 성 | | 부울 | "true": 위치가 초기화됩니다. <br> "false": 위치가 초기화되지 않습니다.
* LocalizationsCore* | | float64 | 범위 : [0.0 ... 1.0] <br> <br>는 현지화의 품질을 설명하므로 현재 위치 정보가 얼마나 정확한지를 설명하기 위해 SLAM AGV에 의해 사용될 수 있습니다.
* DeviationRange* | m | float64 | 미터의 위치의 편차 범위에 대한 값 <br> <br> 편차를 추정 할 수없는 차량의 선택 사항 (그리드 기반 현지화). <br> <br> 로깅 및 시각화 목적으로 만.
x | m | float64 | 맵의 x- 위치 맵 좌표계를 참조하십시오. <br> 정밀도는 특정 구현에 달려 있습니다.
y | m | float64 | 맵 좌표계를 참조하여 맵의 y-position. <br> 정밀도는 특정 구현에 달려 있습니다.
세타 | | float64 | 범위 : [-pi ... pi] <br> <br> AGV의 방향.
Mapid | | 문자열 | 위치가 참조되는 맵의 고유 식별. <br> <br> 각지도는 동일한 좌표 원점을 가지고 있습니다. <br> AGV가 출발 바닥에서 대상 바닥까지 엘리베이터를 사용하면 출발 바닥의지도를 떠나 대상 엘리베이터 노드에서 대상 엘리베이터 노드에서 스폰됩니다.
*mapdescription*<br>} | | 문자열 | 지도에 대한 추가 정보.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 속도 ** {| | JSON 객체 |
* VX* | m/s | float64 | X 방향의 AGV 속도.
* vy* | m/s | float64 | y 방향의 AGV 속도.
*오메가*<br>} | rad/s | float64 | z 축 주위의 AGV의 회전 속도.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
**로드 ** {| | JSON 객체 |
* loadid* | | 문자열 | 하중의 고유 식별 (예 : 바코드 또는 RFID). <br> <br> 빈 필드, AGV가 부하를 식별 할 수 있지만 하중을 아직 식별하지 않은 경우 <br> <br> AGV가 부하를 식별 할 수없는 경우 선택 사항.
* loadType* | | 문자열 | 부하 유형.
*로드 위치* | | 문자열 | 예를 들어, AGV의 부하 처리/운반 장치가 사용되는지, 예를 들어, AGV에 부하를 운반 할 여러 지점/위치가있는 경우. <br> <br> 예를 들어 "전면", "백", "포지션 C1"등이 하나만있는 차량의 옵션 옵션.
*** boundingboxReference *** | | JSON 객체 | 경계 상자의 위치에 대한 참조 지점. <br> 참조 지점은 항상 경계 박스의 바닥 표면 (높이 = 0)의 중심이며 AGV 좌표계의 좌표에 설명되어 있습니다.
*** 하중 분해 *** | | JSON 객체 | 미터의 하중 경계 박스의 치수.
*무게*<br>} | kg | float64 | 범위 : [0.0 ... float64.max] <br> <br> kg으로 측정 된 하중의 절대 중량.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** boundingboxReference ** {| | JSON 객체 | 경계 상자의 위치에 대한 참조 지점. <br> 참조 지점은 항상 경계 박스의 바닥 표면 (높이 = 0)의 중심이며 AGV 좌표계의 좌표에 설명되어 있습니다.
x | | float64 | 참조 지점의 x 코디네이션.
y | | float64 | 참조 지점의 y 좌표.
Z | | 플로트 64 | 참조 지점의 z 코디네스.
*theta*<br>} | | float64 | 하중 경계 상자의 방향. <br> wggger, 기차 등의 경우 중요합니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 하중 분해 ** {| | JSON 객체 | 미터의 하중 경계 박스의 치수.
길이 | m | float64 | 하중 경계 박스의 절대 길이.
너비 | m | float64 | 하중 경계 박스의 절대 너비.
* 높이* <br>} | m | float64 | 하중 경계 상자의 절대 높이. <br> <br> 선택 사항 : <br> <br> 알려진 경우에만 값을 설정하십시오.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** ActionState ** {| | JSON 객체 |
ActionId | | 문자열 | 조치의 고유 식별자.
* ActionType* | | 문자열 | 행동의 유형. <br> <br> 선택 사항 : 정보 또는 시각화 목적으로 만. 마스터 컨트롤은 순서대로 발송 된 행동 유형을 알고 있습니다.
* ActionDescription* | | 문자열 | 현재 행동에 대한 추가 정보.
ActionStatus | | 문자열 | enum { '대기', '초기화', '실행', '일시 정지', '완성', '실패'<br> 섹션 [6.11 actionstates] (#611- 액션 스테이트) 참조.
*resultDescription*<br>} | | 문자열 | 결과에 대한 설명, 예를 들어 RFID 판독 값의 결과 <br> <br> 오류는 오류로 전송됩니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 배터리 상태 ** {| | JSON 객체 | 
배터리 충전 | % | float64 | 충전 상태 : <br> AGV가 배터리 수준이 양호 또는 나쁜 배터리 레벨에 대해서만 값을 제공하는 경우 20% (나쁜) 및 80% (양호)로 표시됩니다. 
* 배터리 볼트* | V | float64 | 배터리 전압.
* 배터리 건강* | % | int8 | 범위 : [0 ... 100] <br> <br> 상태 배터리의 건강을 설명합니다. 
충전 | | 부울 | "True": 진행중인 충전. <br> "False": AGV는 현재 충전되지 않습니다.
* 도달* <br>} | m | UINT32 | 범위 : [0 ... uint32.max] <br> <br> 현재 충전 상태에 대한 추정 범위. 

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 오류 ** {| | JSON 객체 |
errortype | | 문자열 | 유형/오류 이름
*** ERRORREFERENCES [ErrorReference] *** | | 배열 | 오류와 관련된 자세한 정보를 제공하려면 참조 배열 (예 : NodeId, EdgeId, OrderId, ActionID 등). <br> 추가 정보는 [7 Best Practice] (#7-best actractic)를 참조하십시오.
* errordescription* | | 문자열 | 오류의 세부 사항과 가능한 원인을 제공하는 장황한 설명.
* 오류* | | 문자열 | 보고 된 오류에 접근하거나 해결하는 방법에 대한 힌트.
오류 레벨 <br>} | | 문자열 | enum { '경고', '치명적'} <br> <br> <br> '경고': AGV가 시작될 준비가되었습니다 (예 : 유지 보수주기 만료 경고) <br> '치명적': AGV는 실행 상태에 있지 않으며 사용자 개입이 필요합니다 (예 : 레이저 스캐너가 오염됨).

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** ErrorReference ** {| | JSON 객체 |
참조 키 | | 문자열 | 사용 된 참조 유형을 지정합니다 (예 : NodeId, EdgeId, OrderId, ActionId 등).
참조 value <br>} | | 문자열 | 참조 키에 속하는 값. 예를 들어, 오류가 발생한 노드의 ID.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 정보 ** {| | JSON 객체 |
정보 유형 | | 문자열 | 정보 유형/이름.
* 전제 조건 [전신]* | | 배열 | 참조 배열.
* InfodeScription* | | 문자열 | 정보에 대한 설명.
Infolevel <br>} | | 문자열 | enum { 'debug', 'info'} <br> <br> 'debug': 디버깅에 사용. <br> 'info': 시각화에 사용됩니다.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** Inforeference ** {| | JSON 객체 |
참조 키 | | 문자열 | 참조 참조 유형 (예 : Headerid, OrderId, ActionId 등)을 참조하십시오.
참조 value <br>} | | 문자열 | 참조 참조 키에 속하는 값을 참조하십시오.

객체 구조 | 단위 | 데이터 유형 | 설명
--- | --- | --- | ---
** 안전 상태 ** {| | JSON 객체 |
Estop | | 문자열 | enum { 'autoack', 'manual', 'remote', 'none'} <br> <br> endop of estop : <br> 'autoack': auto-acknowledgeable e-stop이 활성화됩니다. 원격으로. <br> 'none': e-stop이 활성화되지 않습니다.
현장의 <br>} | | 부울 | 보호 필드 위반. <br> "True": 필드가 위반됩니다 <br> "False": 필드는 위반되지 않습니다.

#### 작동 모드 설명
다음 설명에는 "state"주제의 OperatingMode가 나와 있습니다.

식별자 | 설명
--- | ---
자동 | AGV는 마스터 컨트롤을 완전히 제어하고 있습니다. <br> AGV는 마스터 컨트롤의 주문에 따라 조치를 추진하고 실행합니다.
반자동 | AGV는 마스터 컨트롤을 통제하고 있습니다. <br> AGV는 마스터 컨트롤의 명령에 따라 조치를 취하고 실행합니다. <br> 구동 속도는 HMI에 의해 제어됩니다 (속도는 자동 모드의 속도를 초과 할 수 없습니다). <br> 스티어링은 자동 제어 (비 안전한 HMI 가능)입니다.
매뉴얼 | 마스터 제어는 AGV를 제어하지 않습니다. <br> 감독자는 운전 명령이나 행동을 AGV에 보내지 않습니다. <br> HMI는 AGV의 스티어링 및 속도 및 처리 장치를 제어하는 ​​데 사용될 수 있습니다. <br> AGV의 위치는 마스터 컨트롤로 전송됩니다. <br> AGV 가이 모드로 들어가거나 떠날 때 즉시 모든 주문을 지 웁니다 (안전한 HMI 필수).
서비스 | 마스터 제어는 AGV를 제어하지 않습니다. <br> 마스터 컨트롤은 운전 명령이나 조치를 AGV에 보내지 않습니다. <br> 공인 직원은 AGV를 재구성 할 수 있습니다.
가르치 | 마스터 제어는 AGV를 제어하지 않습니다. <br> 감독자는 운전 명령이나 행동을 AGV에 보내지 않습니다. <br> AGV를 가르치고 있습니다. 예를 들어, 매핑은 마스터 컨트롤에 의해 수행됩니다.

> 표 1 운영 모드와 그 의미


## 6.11 행동 상태

AGV가`action '(`node` 또는`ed get'에 첨부 된 action '또는'instantAction '을 통해 첨부)을 받으면`actionstates'배열에서`actionstate '와 함께이'액션 '을 나타냅니다.

`ActionStates '는 행동의 수명주기의 어느 단계에서'ActionStatus '필드에서 설명합니다.

표 2는 열거 된 'ActionStatus'가 보유 할 수있는 가치를 평가합니다.

ActionStatus | 설명
--- | ---
'대기'| AGV에 의해 조치가 접수되었지만 트리거가 아직 도달하지 않은 노드 또는 활성화 된 가장자리는 아직 입력되지 않았습니다.
'초기화'| 행동이 유발되었고 준비 조치가 시작되었습니다.
'달리기'| 행동이 실행 중입니다.
'일시 정지'| 일시 정지 인스턴스 또는 외부 트리거로 인해 조치가 일시 중지됩니다 (AGV의 일시 중지 버튼)
'완료'| 액션이 완료되었습니다. <br> 결과는 resultDescription을 통해보고됩니다.
'실패'| 어떤 이유로 든 행동을 완료 할 수 없었습니다.

> 표 2 ActionStatus 필드의 허용 가능한 값

상태 전이 다이어그램은 그림 16에 제공됩니다.

![그림 16 ActionStates에 대한 가능한 모든 상태 전환](./assets/action_state_transition.png)
> 그림 16 ActionStates의 모든 가능한 상태 전환


## 6.12 액션 차단 유형 및 시퀀스

목록에서 여러 조치의 순서는 해당 조치를 실행 해야하는 시퀀스를 정의합니다.
동작의 병렬 실행은 각각의 'BlockingType'에 의해 적용됩니다.

동작은 표 3에 설명 된 세 가지 차단 유형을 가질 수 있습니다.

BlockingType | 설명
--- | ---
없음 | 다른 행동과 병행하여 행동을 실행할 수 있으며 차량이 운전하는 동안 실행할 수 있습니다.
소프트 | 행동은 다른 행동과 병렬로 실행될 수 있습니다. 차량은 운전해서는 안됩니다.
하드 | 행동은 다른 조치와 병행하여 실행되지 않아야합니다. 차량은 운전해서는 안됩니다.

> 표 3 동작 차단 유형

차단 유형이 다른 동일한 노드에 여러 동작이있는 경우, 그림 17은 AGV가 이러한 동작을 어떻게 처리 해야하는지 설명합니다.

!
> 그림 17 여러 작업 처리


## 6.13 주제 "시각화"

거의 실시간 위치 업데이트의 경우 AGV는 '시각화'주제에 대한 위치와 속도를 방송 할 수 있습니다.

위치 객체의 구조는 상태의 위치 및 속도 객체와 동일합니다.
추가 정보는 차량 상태에 대한 섹션 [6.10.6 상태 메시지 구현] (#6106- 구현)을 참조하십시오.
이 주제의 업데이트 속도는 통합기에 의해 정의됩니다.


## 6.14 주제 "연결"

AGV 클라이언트를 브로커에 연결하는 동안 마지막 의지 주제와 메시지를 설정할 수 있으며, 브로커가 브로커와의 연결을 끊을 때 브로커가 게시합니다.
따라서 마스터 컨트롤은 모든 AGV의 연결 주제를 구독하여 연결 끊김 이벤트를 감지 할 수 있습니다.
단절은 중개인과 클라이언트간에 교환되는 하트 비트를 통해 감지됩니다.
간격은 대부분의 중개인에서 구성 가능하며 약 15 초 동안 설정해야합니다.
'연결'주제의 서비스 품질은 1-1-10입니다.

제안 된 마지막 의지 주제 구조는 다음과 같습니다.

** UAGV/V2/Manufacturer/SN/Connection **

마지막 Will 메시지는 다음 필드와 함께 JSON 캡슐화 메시지로 정의됩니다.

식별자 | 데이터 유형 | 설명
--- | --- | ---
Headerid | UINT32 | 메시지의 헤더 ID. <br> Headerid는 주제별로 정의되며 각각의 전송 된 (그러나 반드시 수신 할 필요는 없지만) 1으로 증가합니다.
타임 스탬프 | 문자열 | 타임 스탬프 (ISO8601, UTC); yyyy-mm-ddthh : mm : ss.ffz (예 : "2017-04-15t11 : 40 : 03.12z").
버전 | 문자열 | 프로토콜의 버전 [major]. [minor]. [patch] (예 : 1.3.2).
제조업체 | 문자열 | AGV의 제조업체.
SerialNumber | 문자열 | AGV의 일련 번호.
ConnectionState | 문자열 | enum { 'online', 'offline', 'connectionBroken'} <br> <br> '온라인': AGV와 브로커의 연결이 활성화되어 있습니다. <br> <brl> '오프라인': AGV와 브로커의 연결이 오프라인으로 진행되었습니다. <br> <br> 'ConnectionBroken': AGV와 중개인 간의 연결이 예기치 않게 끝났습니다.
연결이 MQTT 연결 끊김 명령을 사용하여 우아한 방식으로 끝나면 마지막 의지 메시지가 전송되지 않습니다.
마지막 의지 메시지는 연결이 예기치 않게 중단 된 경우 브로커에 의해서만 전송됩니다.

** 참고 ** : 마지막의 특성으로 인해 MQTT의 특징으로 인해 마지막 Will 메시지는 AGV와 MQTT 브로커 간의 연결 단계에서 정의됩니다.
결과적으로 타임 스탬프 및 헤드 레디 필드는 항상 구식입니다.

AGV는 우아하게 연결을 끊고 싶어합니다.

1. AGV는 'UAGV/V2/Manufacturer/SN/Connection”을'ConnectionState '로`offline'으로 설정합니다.
2. 분리 명령으로 MQTT 연결을 분리하십시오.

AGV는 온라인으로 제공됩니다.

1. MQTT 연결이 생성 될 때 'ConnectionState'로 설정된 필드와 함께 "UAGV/V2/Manufacturer/SN/Connection"으로 마지막 의지를 설정하십시오.
2. 'ConnectionState'가 '온라인'으로 설정된 "UAGV/V2/Manufacturer/SN/Connection"주제를 보내십시오.

이 주제에 대한 모든 메시지에는 유지 된 플래그가 표시되어야합니다.

AGV와 브로커 간의 연결이 예기치 않게 중지되면 브로커는 마지막 Will 주제를 보냅니다. "UAGV/V2/Manufacturer/SN/Connection"은 'ConnectionState'가`ConnectionBroken '으로 설정된 필드와 함께 보냅니다.


## 6.15 주제 "Factsheet"

Factsheet은 특정 AGV 유형 시리즈에 대한 기본 정보를 제공합니다.
이 정보는 다양한 AGV 유형을 비교할 수 있으며 AGV 시스템의 계획, 치수 및 시뮬레이션에 적용 할 수 있습니다.
Factsheet에는 AGV 유형 시리즈를 VDA-5050 회사 마스터 컨트롤에 통합하는 데 필요한 AGV 통신 인터페이스에 대한 정보도 포함되어 있습니다.

AGV Factsheet의 일부 필드 값은 시스템 통합 중에 만 지정할 수 있습니다. 예를 들어 프로젝트 별 부하 및 스테이션 유형의 할당과 함께이 AGV가 지원하는 스테이션 및로드 유형 목록.

팩트 시트는 인간이 읽을 수있는 문서와 기계 처리 (예 : 마스터 제어 응용 프로그램에 의한 가져 오기)로 의도되므로 JSON 문서로 지정됩니다.

마스터 컨트롤은 인스턴트 조치`FactSheetRequest '를 보내서 AGV의 Factsheet을 요청할 수 있습니다.

이 주제에 대한 모든 메시지에는 유지 된 플래그가 표시되어야합니다.


### 6.15.1 Factsheet JSON 구조
사실은 다음 표에 나열된 JSON 객체로 구성됩니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| Headerid | UINT32 | 메시지의 헤더 ID. <br> Headerid는 주제별로 정의되며 각각의 전송 된 (그러나 반드시 수신 할 필요는 없지만) 1으로 증가합니다. |
| 타임 스탬프 | 문자열 | 타임 스탬프 (ISO8601, UTC); yyyy-mm-ddthh : mm : ss.ffz (예 : "2017-04-15t11 : 40 : 03.12z"). |
| 버전 | 문자열 | 프로토콜의 버전 [major]. [minor]. [patch] (예 : 1.3.2). |
| 제조업체 | 문자열 | AGV의 제조업체. |
| SerialNumber | 문자열 | AGV의 일련 번호. |
| ** typescification ** JSON 객체 | 이 매개 변수는 일반적으로 AGV의 클래스 및 기능을 지정합니다. |
| ** PhysicalParameters ** | JSON 객체 | 이 매개 변수는 AGV의 기본 물리적 특성을 지정합니다. |
| ** protocollimits ** | JSON 객체 | MQTT 통신에서 식별자, 배열, 문자열 및 유사한 길이에 대한 제한. |
| ** Protocolfeatures ** | JSON 객체 | VDA5050 프로토콜의 지원되는 기능. |
| ** agvgeometry ** | JSON 객체 | AGV 기하학의 상세한 정의. |
| ** 하중 지정 ** | JSON 객체 | 로드 기능의 초록 사양. |
| *** vehicleconfig *** | JSON 객체 | 차량의 현재 소프트웨어 및 하드웨어 버전 요약 및 옵션 네트워크 정보. |

#### typescification

이 JSON 객체는 AGV 유형의 일반적인 특성을 설명합니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| SeriesName | 문자열 | 제조업체가 지정한 무료 텍스트 일반화 시리즈 이름. |
| * SeriesDescription* | 문자열 | 무료 텍스트 AGV 유형 시리즈의 인간 읽기 가능한 설명. |
| Agvkinematic | 문자열 | AGV 운동학 유형에 대한 단순화 된 설명. <br/> [Diff, Omni, Threewheel] <br/> diff : 차동 구동, <br/> omni : omni 방향 차량, <br/> Threewheel : 비슷한 운동학이있는 3 륜구동 차량 또는 차량. |
| agvclass | 문자열 | AGV 클래스에 대한 단순화 된 설명. <br/> [포크리프트, 컨베이어, 잡아 당김, 캐리어] <br/> 포크 리프트 : 포크 리프트, 컨베이어 : 컨베이어가있는 AGV, </br> Tugger : Tugger : <br/> 운송 업체 : 리프팅 장치가 있거나 부하 캐리어. |
| maxloadmass | float64 | [kg], 최대 하중 질량. |
| 현지화 유형 | 문자열 배열 | 현지화 유형에 대한 단순화 된 설명. <br/> 예제 값 : <br/> 자연 : 천연 랜드 마크, <br/> 반사기 : 레이저 반사기, <br/> rfid : rfid 태그, <br/> dmc : data matrix code, <br/> 스팟 : 자기 스팟, <br/> grid : magnetic grid. <br/>
| NavigationTypes | 문자열 배열 | AGV에 의해 지원되는 경로 계획 유형의 배열 우선 순위에 의해 정렬됩니다. <br/> 예제 값 : <br/> Physical_line_guided : 경로 계획 없음, AGV는 물리적 설치 경로를 따릅니다.

#### PhysicalParameters

이 JSON 객체는 AGV의 물리적 특성을 설명합니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| Speedmin | float64 | [M/S] AGV의 최소 제어 연속 속도. |
| SpeedMax | float64 | [m/s] AGV의 최대 속도. |
| * AngularSpeedmin* | float64 | [RAD/S] AGV의 최소 제어 연속 회전 속도. |
| * AngularSpeedmax* | float64 | [RAD/S] AGV의 최대 회전 속도. |
| 가속도 MAX | float64 | [m/s²] 최대 부하의 최대 가속도. |
| 감속 max | float64 | [m/s²] 최대 부하의 최대 감속. |
| 높이 민 | float64 | [M] AGV의 최소 높이. |
| Heightmax | float64 | [M] AGV의 최대 높이. |
| 너비 | float64 | [M] AGV의 너비. |
| 길이 | float64 | [M] AGV의 길이. |

#### protocollimits

이 JSON 객체는 AGV의 프로토콜 제한을 설명합니다.
매개 변수가 정의되지 않거나 0으로 설정되지 않으면이 매개 변수에 대한 명시 적 제한이 없습니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| ** MaxStringLens ** {| JSON 객체 | 줄의 최대 길이. |
| & emsp;* msglen* | UINT32 | 최대 MQTT 메시지 길이. |
| & emsp;* TOTICSERIALLEN* | UINT32 | mqtt-topics의 일련 번호 부품의 최대 길이. <br/> <br/> 영향을받는 매개 변수 : <br/> order.serialnumber <br/> instantactions.serialnumber <br/> state.serialnumber <br/> visualization.serialnumber <br/> connection.serialnumber |
| & emsp;* topicelemlen* | UINT32 | MQTT 주제에서 다른 모든 부품의 최대 길이. <br/> <br/> 영향 매개 변수 : <br/> order.timestamp <br/> order.version <br/> order.manufacturer <br/> instantAction.timestamp <br/> instantAction.version <brsion <brsion <brsion <br/> instantAction.manufacturer <br/> state.timestamp <br/> state. 버전 <br/> state.manufacturer <br/> visualization.timestamp <br/> visualization.version. visualization.manuction.manuction.manuction.timestamp <br/> connection.version.manufacturer |
| & emsp;* idlen* | UINT32 | ID 문자열의 최대 길이. <br/> <br/> 영향을받은 매개 변수 : <br/> order.OrderId <br/> order.zonesetid <br/> node.node.nodeid.mapitos.mapid.mapid <br/> ActionId <br/> edod.edge.edge.edge.edge.edge.startnodeid <br/> edver.endnodeid |
| & emsp;* idnumericalonly* | 부울 | "True"ID 문자열이 숫자 값 만 포함 해야하는 경우. |
| & emsp;* enumlen* | UINT32 | 열거 및 키 문자열의 최대 길이. <br/> <br/> 영향을받은 매개 변수 : <br/> action.actionType action.blockingtype <br/> edge.direction <br/> actionparameter.key <br/> state.operatingMode <br/> load.Load.Load.loadType <br/> actionStatus <br/ > ERROR.ERRORTYPE <BR/> ERROR.ERRORLEVEL <BR/> ERRERREFERNE.REFERFENCE.REFERFENCE <br/> info.infotype <br/> info.infolevel <br/> SafetyState.estop <br/> Connection.connectionState |
| & emsp;* loadidlen* | UINT32 | 로드 스트링의 최대 길이. |
| } | | |
| ** maxarraylens ** {| JSON 객체 | 최대 배열 길이. |
| & emsp;* Order.Nodes* | UINT32 | AGV가 처리 할 수있는 주문 당 최대 노드 수. |
| & emsp;* order.edges* | UINT32 | AGV가 처리 할 수있는 주문 당 최대 가장자리 수. |
| & emsp;* node.actions* | UINT32 | AGV가 처리 할 수있는 노드 당 최대 작업 수. |
| & emsp;* edge.actions* | UINT32 | AGV가 처리 할 수있는 가장자리 당 최대 조치 수. |
| & emsp;* actions.actionsparameters* | UINT32 | AGV가 처리 할 수있는 동작 당 최대 매개 변수 수. |
| & emsp;* InstantAction* | UINT32 | AGV가 처리 할 수있는 메시지 당 최대 인스턴트 작업 수. |
| & emsp;* trajectory.knotvector* | UINT32 | AGV가 처리 할 수있는 궤적 당 최대 매듭 수. |
| & emsp;* trajectory.controlpoints* | UINT32 | AGV가 처리 할 수있는 궤적 당 최대 제어점 수. |
| & emsp;* state.nodestates* | UINT32 | AGV에 의해 전송 된 최대 Nodestates, AGV 기반의 최대 노드 수. |
| & emsp;* state.edgestates* | UINT32 | AGV에 의해 전송 된 최대 에드 키 테이트 수, AGV베이스의 최대 가장자리 수. |
| & emsp;* state.loads* | UINT32 | AGV가 보낸 최대로드 오브젝트 수. |
| & emsp;* state.actionstates* | UINT32 | AGV가 보낸 최대 액션 스테이트 수 |
| & emsp;* state.errors* | UINT32 | 한 상태 메시지에서 AGV가 전송하는 최대 오류 수. |
| & emsp;* state.information* | UINT32 | 한 상태 메시지로 AGV가 전송 한 최대 정보 수. |
| & emsp;* ERROR.ERRORREFERENCES* | UINT32 | 각 오류에 대해 AGV가 전송하는 최대 오류 참조 수. |
| & emsp;* information.inforeferences* | UINT32 | 각 정보에 대해 AGV가 보낸 최대 정보 참조 수. |
| } | | |
| ** 타이밍 ** {| JSON 객체 | 타이밍 정보. |
| & emsp; minorderinterval | float32 | [S], AGV에 주문 메시지를 보내는 최소 간격. |
| & emsp; minstateinterval | float32 | [S], 상태 메시지를 보내기위한 최소 간격. |
| & emsp;* DefaultStateInterval* | float32 | [S], 상태 메시지를 전송하기위한 기본 간격 *정의되지 않은 경우 기본 문서의 기본값이 사용됩니다 *. |
| & emsp;* VisublizationInterval* | float32 | [S], 시각화 주제에서 메시지를 보내기위한 기본 간격. |
| } | | |

#### protocolfeatures

이 JSON 객체는 AGV에서 지원하는 작업 및 매개 변수를 정의합니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| ** 옵션 파라미터 ** [** 옵션 파라미터 **] | JSON 객체의 배열 | 지원 및/또는 필수 선택적 매개 변수 배열 <br/> 여기에 나열되지 않은 선택적 매개 변수는 AGV에 의해 지원되지 않는 것으로 가정합니다. |
| {| | |
| & emsp; 매개 변수 | 문자열 | 선택적 매개 변수의 전체 이름 (예 : "*order.nodes.nodeposition.allowedDeviationTha"*. |
| & emsp; 지원 | 열거 | 옵션 매개 변수에 대한 지원 유형, 다음 값이 가능합니다. <br/> 'supported': 옵션 매개 변수는 지정된 것처럼 지원됩니다. <br/> '필수': 적절한 AGV 작동에는 선택적 매개 변수가 필요합니다. |
| & emsp;*설명*| 문자열 | 자유 형식 텍스트 : 선택적 매개 변수에 대한 설명 (예 : <ul> <li> 이유, <ul> <li> 이유,이 AGV 유형에 필요한 옵션 방향이 필요한 이유와 그 값이 포함될 수있는 값.
| } | | |
| ** agvactions ** [** agvaction **] | JSON 객체의 배열 | 이 AGV에서 지원하는 매개 변수를 사용한 모든 작업의 ​​배열. 여기에는 VDA5050에 지정된 표준 조치 및 제조업체 별 동작이 포함됩니다. |
| {| | |
| & emsp; ActionType | 문자열 | Action.actyType에 해당하는 고유 한 유형의 동작. |
| & emsp;* ActionDescription* | 문자열 | 자유 형식 텍스트 : 행동에 대한 설명. |
| & emsp; ActionScopes | 열거의 배열 | 이 동작 유형을 사용할 수있는 허용 범위의 배열. <br/> <br/> 'Instant': InstantAction으로 사용 가능합니다. <br/> 'Node': 노드에서 사용 가능. <br/> 'edge': 가장자리에서 사용 가능. [ 'instant', 'node'] |
| & emsp; *** ActionParameters ** [** ActionParameter **]*| JSON 객체의 배열 | action의 배열은 다음과 같습니다. <br/> 정의되지 않으면 동작에는 매개 변수가 없습니다. <br/> 여기에 정의 된 JSON 객체는 섹션 [6.6.6 순서 메시지 구현] (#666-implementation-of the the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-the-with-message)에 사용 된 것과 다른 JSON 객체입니다.
| & emsp;* {* | | |
| & emsp; & emsp; 키 | 문자열 | 매개 변수의 주요 문자열. |
| & emsp; & emsp; valueUdatAtype | 열거 | 데이터 유형의 값, 가능한 데이터 유형은 'bool', 'number', 'integer', 'float', 'string', 'object', 'array'입니다. |
| & emsp; & emsp;* 설명* | 문자열 | 자유 형식 텍스트 : 매개 변수 설명. |
| & emsp; & emsp;* isoptional* | 부울 | "true": 선택적 매개 변수. |
| & emsp;*}* | | |
|* resultDescription* | 문자열 | 자유 형식 텍스트 : 결과에 대한 설명. |
|* BlockingTypes* | 열거의 배열 | 정의 된 동작을위한 가능한 차단 유형 배열. </br> enum { 'none', 'soft', 'hard'} |
|*}* | | |

### agvgeometry

이 JSON 객체는 AGV의 형상 특성 (예를 들어 윤곽선 및 휠 위치를 정의합니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| *** wheeldefinitions ** [** wheeldefinition **]*| JSON 객체의 배열 | 휠 배열 및 형상을 포함하는 휠 배열. |
| {| | |
| & emsp; 유형 | 열거 | 휠 타입 <br/> enum { 'Drive', 'Caster', '고정', 'Mecanum'}. |
| & emsp; isactivedRiven | 부울 | "진정한": 휠은 적극적으로 구동됩니다. |
| & emsp; isactivesteered | 부울 | "진정한": 휠이 적극적으로 조종됩니다. |
| & emsp; ** 위치 ** {| JSON 객체 | |
| & emsp; & emsp; x | float64 | [M], AGV 좌표계의 X- 위치. |
| & emsp; & emsp; y | float64 | [M], AGV 좌표계의 y-position. |
| & emsp; & emsp; * theta* | float64 | [RAD], AGV 좌표계에서 휠의 방향. 고정 휠에 필요합니다. |
| & emsp;} | | |
| & EMSP; 직경 | float64 | [M], 휠의 공칭 직경. |
| & emsp; 너비 | float64 | [M], 휠의 공칭 폭. |
| & emsp;* CenterDispalmention* | float64 | [M], 휠 중심이 회전 지점으로의 공칭 변위 (캐스터 휠에 필요한). <br/> 매개 변수가 정의되지 않은 경우 0이라고 가정합니다. |
| & emsp;* 제약 조건* | 문자열 | 자유 형식 텍스트 : 제조업체가 제약 조건을 정의하는 데 사용할 수 있습니다. |
| } | | |
| *** envelopes2d ** [** envelope2d **]*| JSON 객체의 배열 | 2D의 AGV 봉투 곡선, 예를 들어, 언로드 및로드 상태를위한 기계식 봉투, 다양한 속도 케이스에 대한 안전 필드. |
| {| | |
| & emsp; set | 문자열 | 봉투 곡선 세트의 이름. |
| & emsp; ** 다각형 ** ** [polygonpoint] ** | JSON 객체의 배열 | x/y- 폴리 원형 다각형으로서의 봉투 곡선은 닫힌 것으로 가정되며 셀프 사이터링되지 않아야합니다. |
| & emsp; {| | |
| & emsp; & emsp; x | float64 | [M], 다각형 포인트의 X- 위치. |
| & emsp; & emsp; y | float64 | [M], 다각형 포인트의 y- 위치. |
| & emsp;} | | |
| & emsp;* 설명* | 문자열 | 자유 형식 텍스트 : 봉투 곡선 세트의 설명. |
| *}* | | |
| *** envelopes3d [envelope3d] *** | JSON 객체의 배열 | 3D의 AGV 봉투 곡선 배열. |
| * {* | | |
| & emsp; set | 문자열 | 봉투 곡선 세트의 이름. |
| & emsp; 형식 | 문자열 | 데이터 형식 (예 : DXF). |
| & emsp; *** data *** | JSON 객체 | '형식'에 지정된 3D-ENVELOPE CURVE 데이터, 형식. |
| & emsp;* url* | 문자열 | 3D-envelope 곡선 데이터를 다운로드하기위한 프로토콜 및 URL 정의 (예 : <ftp://xxx.yyy.com/ac4dgvhoif5tghji>. |
| & emsp;* 설명* | 문자열 | 자유 형식 텍스트 : 봉투 곡선 세트의 설명 |
| *}* | | |

#### loadspecification

이 JSON 객체는 AGV의 부하 처리 및 지원되는로드 유형을 지정합니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| * 하중 위치* | 문자열 배열 | 부하 위치/로드 처리 장치. <br/>이 배열은 매개 변수 "state.loads []. loadposition"및 작업 선택의 "lhd"에 대한 유효한 값이 포함되어 있습니다. <br/>*이 배열이 존재하지 않거나 비어 있으면 AGV에는 부하 처리 장치가 없습니다.* |
| ***로드 세트 [로드 세트] *** | JSON 객체의 배열 | AGV가 처리 할 수있는로드 세트의 배열 |
| {| | |
| & emsp; setName | 문자열 | 로드 세트의 고유 한 이름 (예 : 기본값, set1 등) |
| & emsp; loadType | 문자열 | 하중 유형 (예 : Epal, XLT1200 등) |
| & emsp; * 하중 위치* | 문자열 배열 | 부하 위치 BTW 배열. 부하 처리 장치,이로드 세트는. <br/>*에 유효합니다. <br/>*이 매개 변수가 존재하지 않거나 비어 있으면이로드 세트는이 AGV의 모든로드 처리 장치에 유효합니다.* |
| & emsp; *** boundingboxReference *** | JSON 객체 | 상태 메시지에서 매개 변수로드 []에 정의 된 바인딩 박스 참조. |
| & emsp; *** 하중 분해 *** | JSON 객체 | 상태 메시지에서 매개 변수로드 []에 정의 된로드 치수. |
| & emsp; * maxweight* | float64 | [kg], 하중 유형의 최대 무게. |
| & emsp; * MinloadhandlingHeight* | float64 | [M],이 하중 유형의 처리를위한 최소 허용 높이 및 체중 <br/> BoundingboxReference에 대한 참조. |
| & emsp; * MaxloadhandlingHeight* | float64 | [M],이 하중 유형의 처리를위한 최대 허용 높이 및 체중 <br/> 경계 박스 레퍼런스에 대한 참조. |
| & emsp; * minloadhandlingdepth* | float64 | [M],이 하중 유형에 대한 최소 허용 깊이 및 체중 <br/> 경계 박스 레퍼런스에 대한 참조. |
| & emsp; * maxloadhandlingdepth* | float64 | [M],이 하중 유형에 대한 최대 허용 깊이 및 체중 <br/> 경계 박스 레퍼런스에 대한 참조. |
| & emsp; * minloadhandlingtilt* | float64 | [RAD],이 하중 유형 및 무게에 대해 최소 허용 틸트. |
| & emsp; * maxloadhandlingtilt* | float64 | [RAD],이 하중 유형 및 무게에 대한 최대 허용 틸트. |
| & emsp; * AgvSpeedLimit* | float64 | [m/s],이 하중 유형 및 무게에 대한 최대 허용 속도. |
| & emsp; * agvaccelerationlimit* | float64 | [m/s²],이 하중 유형 및 무게에 대한 최대 허용 가속도. |
| & emsp; * agvdecelerationlimit* | float64 | [m/s²],이 하중 유형 및 무게에 대한 최대 허용 감속. |
| & emsp; * picktime* | float64 | [S], 대략. 부하를 집어 들기위한 시간 |
| & emsp; * 드롭 타임* | float64 | [S], 대략. 부하를 떨어 뜨리는 시간. |
| & emsp; * 설명* | 문자열 | 자유 형식 텍스트 : 부하 처리 세트에 대한 설명. |
| } | | |

#### vehicleconfig

이 JSON 객체는 차량에서 실행되는 소프트웨어 및 하드웨어 버전과 네트워크 정보에 대한 간단한 요약에 대해 자세히 설명합니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
| * 버전 [versioninfo]* | JSON 객체의 배열 | 소프트웨어 및 하드웨어 정보가 포함 된 키 값 쌍 개체 배열 | | {| | |
| & emsp; 키 | 문자열 | 사용 된 소프트웨어/하드웨어 버전의 키. (예 : 소프트웨어 버전) |
| & emsp; 가치 | 문자열 | 키에 해당하는 버전. (예 : v1.12.4-beta) |
| } | | |
| * 네트워크* {| JSON 객체 | 차량의 네트워크 연결에 대한 정보. 차량이 운영되는 동안 나열된 정보는 업데이트되지 않아야합니다. |
| & emsp; & emsp; * dnsservers* | 문자열 배열 | 차량에서 사용하는 도메인 이름 서버 (DNS) 배열. |
| & emsp; & emsp; * ntpservers* | 문자열 배열 | 차량에서 사용하는 NTP (Network Time Protocol) 서버. |
| & emsp; & emsp; * localipaddress* | 문자열 | MQTT 브로커와 통신하는 데 사용되는 선험적 인 IP 주소. 이 IP 주소는 작업 중에 수정/변경되어서는 안됩니다. |
| & emsp; & emsp; * netmask* | 문자열 | 로컬 IP 주소에 해당하는 네트워크 구성에 사용되는 서브넷 마스크. |
| & emsp; & emsp; * defaultgateway* | 문자열 | 로컬 IP 주소에 해당하는 차량에서 사용하는 기본 게이트웨이. |
| & emsp;} | | |


# 7 모범 사례
이 섹션에는 추가 정보가 포함되어있어 프로토콜의 논리와 동시에 공통된 이해를 촉진하는 데 도움이됩니다.

## 7.1 오류 참조

오류가 잘못된 순서로 인해 오류가 발생하면 AGV는 필드 오류 references에서 의미있는 오류 참조를 반환해야합니다 (State 메시지의 섹션 [6.10.6 구현 섹션] (#6106- 상태 주제).
여기에는 다음 정보가 포함될 수 있습니다.

-`headerid`
- 주제 (`order` 또는 'instantaction')
-`orderid` 및`OrderUpDateId` 주문 업데이트로 인해 오류가 발생한 경우
-`actionID '는 오류가 조치로 인해 발생했을 경우
- 오류가 잘못된 조치 매개 변수로 인해 오류가 발생한 경우 매개 변수 목록

외부 요인 (예 : 예상 위치에 부하가 없음)으로 인해 작업을 완료 할 수없는 경우 ActionID를 참조해야합니다.


## 7.2 매개 변수 형식

오류, 정보 및 작업에 대한 매개 변수는 키 값 쌍이있는 JSON 객체 배열로 설계되었습니다.

| ** 필드 ** | ** 데이터 유형 ** | ** 설명 ** |
| --- | --- | --- |
** ActionParameter ** {| JSON 객체 | 표시된 동작에 대한 ActionParameter (예 : deviceid, loadid, 외부 트리거).
키 | 문자열 | 매개 변수의 키.
값 </br>} | 중 하나 : </br> 배열, </br> 부울, </br> 숫자, </br> 문자열, </br> 객체 | 키에 속하는 매개 변수의 값.

Stattype 및 LoadType에 대한 키 값 쌍의 동작 "someaction"의 'ActionParameter'에 대한 예 :

"ActionParameters": [
{ "키": "Stattype", "Value": "Floor"},
{ "키": "무게", "값": 8.5},
{ "키": "loadType", "value": "pallet_eu"}
]]

"Key": "실제 키", "value": "real value"의 제안 된 체계를 사용하는 이유는 구현을 일반적인 상태로 유지하는 것입니다. "실제 값"은 Float, Bool 및 객체와 같은 가능한 JSON 데이터 유형 일 수 있습니다.


# 8 용어집


## 8.1 정의

개념 | 설명
--- | ---
무료 내비게이션 AGV | 지도를 사용하여 자신의 경로를 계획하는 차량. <br> 마스터 컨트롤은 시작 및 목적지 좌표 만 보냅니다. <br> 차량은 마스터 컨트롤로 경로를 보냅니다. <br> 마스터 컨트롤과의 연결이 파손되면 차량은 여행을 계속할 수 있습니다. <br> 무료 개발 차량은 로컬 장애물을 우회 할 수 있습니다.
가이드 차량 (물리적 또는 가상) | 마스터 컨트롤이 경로를 보낸 차량. <br> 경로의 계산은 마스터 컨트롤에서 발생합니다. <br> 마스터 제어와의 통신이 끊어지면 차량은 해제 된 노드와 가장자리 ( "베이스")를 종료 한 다음 중지됩니다. <br> 가이드 차량은 지역 장애물을 우회 할 수 있습니다. <br> 또한 수신/분배 위치의 미세 조정은 또한 수신/분배 위치를 조정할 수도 있습니다.
중앙지도 | 마스터 컨트롤에서 중앙에서 유지 될지도. <br> 이것은 처음에 생성 된 다음 사용됩니다.